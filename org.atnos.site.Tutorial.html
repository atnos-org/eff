<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Tutorial</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint(); tabberAutomatic([])">

<div class="container">

<div class="col-md-2 col-sm-3 col-xs-3 sidebar-outer">
<div class="col-md-2 fixed">

<!-- search box -->
<div class="search-box">
  <form action="search.html">
    <input type="text" name="q" id="tipue_search_input" autocomplete="off" required>
  </form>
</div>

<!-- table of contents -->
<div id="tree"><ul>
                <li id="index"><a href="index.html" title="eff">eff</a>
      <ul><ul><li><a href="index.html#contributing" title="Contributing">Contributing</a>
          
        </li></ul></ul>
      <ul>
                    <ul>
                <li id="org-atnos-site-installation"><a href="org.atnos.site.Installation.html" title="Installation">Installation</a>
      <ul><ul><li><a href="org.atnos.site.Installation.html#additional-dependencies" title="Additional dependencies">Additional depe...</a>
          
        </li><li><a href="org.atnos.site.Installation.html#imports" title="Imports">Imports</a>
          <ul><li><a href="org.atnos.site.Installation.html#main-types" title="Main types">Main types</a>
          
        </li><li><a href="org.atnos.site.Installation.html#creating-effects" title="Creating effects">Creating effects</a>
          
        </li><li><a href="org.atnos.site.Installation.html#interpreting-effects" title="Interpreting effects">Interpreting ef...</a>
          
        </li><li><a href="org.atnos.site.Installation.html#intellij-support" title="Intellij support">Intellij support</a>
          
        </li><li><a href="org.atnos.site.Installation.html#with-scalaz" title="With Scalaz">With Scalaz</a>
          
        </li></ul>
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-introduction"><a href="org.atnos.site.Introduction.html" title="Introduction">Introduction</a>
      <ul><ul><li><a href="org.atnos.site.Introduction.html#first-example" title="First example">First example</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-outofthebox"><a href="org.atnos.site.OutOfTheBox.html" title="Out of the box">Out of the box</a>
      <ul><ul><li><a href="org.atnos.site.OutOfTheBox.html#what’s-next?" title="What’s next?">What’s next?</a>
          
        </li></ul></ul>
      <ul>
                    <ul>
                <li id="org-atnos-site-lib-evaleffectpage"><a href="org.atnos.site.lib.EvalEffectPage.html" title="Eval">Eval</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-optioneffectpage"><a href="org.atnos.site.lib.OptionEffectPage.html" title="Option">Option</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-eithereffectpage"><a href="org.atnos.site.lib.EitherEffectPage.html" title="Either">Either</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-validateeffectpage"><a href="org.atnos.site.lib.ValidateEffectPage.html" title="Validate">Validate</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-erroreffectpage"><a href="org.atnos.site.lib.ErrorEffectPage.html" title="Error">Error</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-readereffectpage"><a href="org.atnos.site.lib.ReaderEffectPage.html" title="Reader">Reader</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-writereffectpage"><a href="org.atnos.site.lib.WriterEffectPage.html" title="Writer">Writer</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-stateeffectpage"><a href="org.atnos.site.lib.StateEffectPage.html" title="State">State</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-listeffectpage"><a href="org.atnos.site.lib.ListEffectPage.html" title="List">List</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-chooseeffectpage"><a href="org.atnos.site.lib.ChooseEffectPage.html" title="Choose">Choose</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-memoeffectpage"><a href="org.atnos.site.lib.MemoEffectPage.html" title="Memo">Memo</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-timedfutureeffectpage"><a href="org.atnos.site.lib.TimedFutureEffectPage.html" title="TimedFuture">TimedFuture</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-taskeffectpage"><a href="org.atnos.site.lib.TaskEffectPage.html" title="Task">Task</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-lib-safeeffectpage"><a href="org.atnos.site.lib.SafeEffectPage.html" title="Safe">Safe</a>
      <ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul>
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-tutorial"><a href="org.atnos.site.Tutorial.html" title="Tutorial">Tutorial</a>
      <ul><ul><li><a href="org.atnos.site.Tutorial.html#study-your-topic" title="Study your topic">Study your topic</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#create-an-adt
representing-your-grammar" title="Create an ADT
representing your grammar">Create an ADT
r...</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#free-your-adt" title="Free your ADT">Free your ADT</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#create-smart
constructors-using-eff.send" title="Create smart
constructors using Eff.send">Create smart
co...</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#build-a-program" title="Build a program">Build a program</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#write-an-interpreter-for
your-program" title="Write an interpreter for
your program">Write an interp...</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#run-your-program" title="Run your program">Run your program</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#add-some-syntax" title="Add some syntax">Add some syntax</a>
          
        </li><li><a href="org.atnos.site.Tutorial.html#composing-adts-with-the-eff
monad" title="Composing ADTs with the Eff
monad">Composing ADTs ...</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-createeffects"><a href="org.atnos.site.CreateEffects.html" title="Creating effects">Creating effects</a>
      <ul><ul><li><a href="org.atnos.site.CreateEffects.html#creation" title="Creation">Creation</a>
          
        </li><li><a href="org.atnos.site.CreateEffects.html#compiler-limitation" title="Compiler limitation">Compiler limita...</a>
          
        </li><li><a href="org.atnos.site.CreateEffects.html#interpreter" title="Interpreter">Interpreter</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-transformstack"><a href="org.atnos.site.TransformStack.html" title="Transform stacks">Transform stacks</a>
      <ul><ul><li><a href="org.atnos.site.TransformStack.html#what-is-an-“effect-stack”?" title="What is an “effect stack”?">What is an “eff...</a>
          
        </li><li><a href="org.atnos.site.TransformStack.html#transform-an-effect-to
another" title="Transform an effect to
another">Transform an ef...</a>
          <ul><li><a href="org.atnos.site.TransformStack.html#change-the-effect" title="Change the effect">Change the effect</a>
          
        </li></ul>
        </li><li><a href="org.atnos.site.TransformStack.html#translate-an-effect
into-multiple-others" title="Translate an effect
into multiple others">Translate an ef...</a>
          
        </li><li><a href="org.atnos.site.TransformStack.html#interpret-an-effect-“locally”" title="Interpret an effect “locally”">Interpret an ef...</a>
          
        </li><li><a href="org.atnos.site.TransformStack.html#merge-stacks" title="Merge stacks">Merge stacks</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-memberimplicits"><a href="org.atnos.site.MemberImplicits.html" title="Member implicits">Member implicits</a>
      <ul><ul><li><a href="org.atnos.site.MemberImplicits.html#running-effects
with-several-type-parameters" title="Running effects
with several type parameters">Running effects...</a>
          
        </li><li><a href="org.atnos.site.MemberImplicits.html#use-context-bounds-and-type
aliases" title="Use context bounds and type
aliases">Use context bou...</a>
          
        </li><li><a href="org.atnos.site.MemberImplicits.html#know-your-member
typeclasses" title="Know your Member
typeclasses">Know your Membe...</a>
          
        </li><li><a href="org.atnos.site.MemberImplicits.html#“packing”-member-instances" title="“Packing” member instances">“Packing” membe...</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-applicativeevaluation"><a href="org.atnos.site.ApplicativeEvaluation.html" title="Applicative">Applicative</a>
      <ul><ul><li><a href="org.atnos.site.ApplicativeEvaluation.html#concurrent-evaluation" title="Concurrent evaluation">Concurrent eval...</a>
          
        </li><li><a href="org.atnos.site.ApplicativeEvaluation.html#batching" title="Batching">Batching</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-cookbook"><a href="org.atnos.site.Cookbook.html" title="Cookbook">Cookbook</a>
      <ul><ul><li><a href="org.atnos.site.Cookbook.html#partial-interpretation" title="Partial Interpretation">Partial Interpr...</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul><ul>
                <li id="org-atnos-site-communityresources"><a href="org.atnos.site.CommunityResources.html" title="Community resources">Community resou...</a>
      <ul><ul><li><a href="org.atnos.site.CommunityResources.html#blog-posts" title="Blog posts">Blog posts</a>
          
        </li><li><a href="org.atnos.site.CommunityResources.html#tutorials-&amp;-examples" title="Tutorials &amp; Examples">Tutorials &amp; Exa...</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul>
                  </ul>
    </li>
              </ul></div><script>$(function () { $('#tree').jstree({'core':{'initially_open':['index','org-atnos-site-tutorial'], 'animation':200}, 'themes' : {'theme': 'default','url': './css/themes/default/style.css'}, 'plugins':['themes', 'html_data']}); });</script>

</div>
</div>


<div class="col-md-10 col-sm-9 col-xs-9">
<h1>Tutorial</h1>
<div id="tipue_search_content"></div>

<p>This tutorial is intentionally structured like the <a
href="https://typelevel.org/cats/datatypes/freemonad.html">Free monad
tutorial for cats</a> so that a side-by-side comparison of the 2
approaches is possible.</p>
<h3 id="study-your-topic">Study your topic</h3>
<p>Let’s imagine that we want to create a DSL for a key-value store. We
want to be able to do three things with keys:</p>
<ul>
<li>put a value into the store, associated with its key.</li>
<li>get a value from the store given its key.</li>
<li>delete a value from the store given its key.
<p/></li>
</ul>
<p>The idea is to write a sequence of these operations in the embedded
DSL as a “program”, interpret the “program”, and finally execute the
“program” to interact with the actual key-value store.</p>
<p>For example:</p>
<pre><code class="prettyprint"> put(&quot;toto&quot;, 3)
 get(&quot;toto&quot;) // returns 3
 delete(&quot;toto&quot;)</code></pre>
<p>But we want:</p>
<ul>
<li>the computation to be represented as a pure, immutable value</li>
<li>to separate the creation and execution of the program</li>
<li>to be able to support many different methods of execution</li>
</ul>
<h3 id="create-an-adt-representing-your-grammar">Create an ADT
representing your grammar</h3>
<p>ADT stands for “Algebraic Data Type”. In this context, it refers to a
closed set of types which can be combined to build up complex, recursive
values.</p>
<p>We need to create an ADT to represent our key-value operations:</p>
<pre><code class="prettyprint">// the type parameter A can be read as the type of value returned by the operation
  sealed trait KVStore[+A]

  case class Put[T](key: String, value: T) extends KVStore[Unit]
  case class Get[T](key: String) extends KVStore[Option[T]]
  case class Delete(key: String) extends KVStore[Unit]
</code></pre>
<h3 id="free-your-adt">Free your ADT</h3>
<p>There are four basic steps to “freeing” the ADT:</p>
<ol type="1">
<li>Create smart constructors for <code class="prettyprint">KVStore[_]</code> using
<code class="prettyprint">Eff.send</code></li>
<li>Build a program out of key-value DSL operations</li>
<li>Build an interpreter for programs of DSL operations</li>
<li>Execute our interpreted program</li>
<li>[optional] add some syntax for the interpreter</li>
</ol>
<h3 id="create-smart-constructors-using-eff.send">Create smart
constructors using <code class="prettyprint">Eff.send</code></h3>
<p>These methods will let you create <code class="prettyprint">Eff</code> values for your
key-value store “Effect”:</p>
<pre><code class="prettyprint">  import org.atnos.eff._

// T |= R is an alias for MemberIn[T, R]
// stating that effects of type T[_] can be injected in the effect stack R
// It is also equivalent to MemberIn[KVStore, R]
  type _kvstore[R] = KVStore |= R

  /** store returns nothing (i.e. Unit) */
  def store[T, R: _kvstore](key: String, value: T): Eff[R, Unit] =
    Eff.send[KVStore, R, Unit](Put(key, value))

  /** find returns a T value if the key exists */
  def find[T, R: _kvstore](key: String): Eff[R, Option[T]] =
    Eff.send[KVStore, R, Option[T]](Get(key))

  /** delete returns nothing (i.e. Unit) */
  def delete[T, R: _kvstore](key: String): Eff[R, Unit] =
    Eff.send(Delete(key))

  /** update composes get and put, and returns nothing. */
  def update[T, R: _kvstore](key: String, f: T =&gt; T): Eff[R, Unit] =
    for {
      ot &lt;- find[T, R](key)
      _ &lt;- ot.map(t =&gt; store[T, R](key, f(t))).getOrElse(Eff.pure(()))
    } yield ()
</code></pre>
<p>Each method requires the <code class="prettyprint">KVStore</code> effect to be a member
of an “effect stack” <code class="prettyprint">R</code>. The return values are of type
<code class="prettyprint">Eff[R, A]</code> where <code class="prettyprint">R</code> is a stack of effects
possibly containing other effects than key-value store operations and
yielding values of type <code class="prettyprint">A</code>.</p>
<h3 id="build-a-program">Build a program</h3>
<p>Now that we can construct values with <code class="prettyprint">KVStore</code> effects we
can use our DSL to write “programs” using a for-comprehension:</p>
<pre><code class="prettyprint">  import org.atnos.eff._

  def program[R: _kvstore]: Eff[R, Option[Int]] =
    for {
      _ &lt;- store(&quot;wild-cats&quot;, 2)
      _ &lt;- update[Int, R](&quot;wild-cats&quot;, _ + 12)
      _ &lt;- store(&quot;tame-cats&quot;, 5)
      n &lt;- find[Int, R](&quot;wild-cats&quot;)
      _ &lt;- delete(&quot;tame-cats&quot;)
    } yield n
</code></pre>
<p>This looks like a monadic flow. However, it just builds a recursive
data structure representing the sequence of operations.</p>
<h3 id="write-an-interpreter-for-your-program">Write an interpreter for
your program</h3>
<p>As you may have understood now, <code class="prettyprint">Eff</code> is used to create an
embedded DSL. By itself, this DSL only represents a sequence of
operations (defined by a recursive data structure); it doesn’t produce
anything.</p>
<p><code class="prettyprint">Eff</code> is a programming language inside your programming
language!</p>
<p>So, like any other programming language, we need to interpret our
abstract language into concrete values.</p>
<p>To do this, we will use an interpreter transforming our
<code class="prettyprint">KVStore</code> effects using a simple mutable map:</p>
<pre><code class="prettyprint">  import org.atnos.eff._
  import interpret._
  import cats.Traverse
  import cats.implicits._
  import scala.collection.mutable._

  /**
 * Unsafe interpreter for KVStore effects
 *
 * the program will crash if a type is incorrectly specified.
 *
 * The interpreter requires the KVStore effect to be a Member of R (with &lt;=)
 * Meaning that we can statically know the resulting type once we have removed
 * KVStore from R, and this type is m.Out.
 *
 * The interpreter uses the `interpretUnsafe` method from `org.atnos.eff.Interpreter` to implement a
 * stack-safe interpretation of effects as a side-effect.
 *
 * `interpretUnsafe` needs the definition of a side-effect where
 * we get each `KVStore[X]` effect, run side-effects and return a value `X`.
 *
 * The resulting effect stack is m.Out which is R without the KVStore effects
 *
 */
  def runKVStoreUnsafe[R, A](effects: Eff[R, A])(implicit m: KVStore &lt;= R): Eff[m.Out, A] = {
    // a very simple (and imprecise) key-value store
    val kvs = Map.empty[String, Any]

    val sideEffect = new SideEffect[KVStore] {
      def apply[X](kv: KVStore[X]): X =
        kv match {
          case Put(key, value) =&gt;
            println(s&quot;put($key, $value)&quot;)
            kvs.put(key, value)
            ()

          case Get(key) =&gt;
            println(s&quot;get($key)&quot;)
            kvs.get(key)

          case Delete(key) =&gt;
            println(s&quot;delete($key)&quot;)
            kvs.remove(key)
            ()
        }

      def applicative[X, Tr[_]: Traverse](ms: Tr[KVStore[X]]): Tr[X] =
        ms.map(apply)
    }
    interpretUnsafe(effects)(sideEffect)(m)

  }
</code></pre>
<p>Please note this interpreter is impure – it mutates <code class="prettyprint">kvs</code>
and also produces logging output using <code class="prettyprint">println</code>. The whole
purpose of functional programming isn’t to prevent side-effects, it is
just to push side-effects to the boundaries of your system in a
well-known and controlled way.</p>
<p>We can also interpret <code class="prettyprint">KVStore</code> effects differently and
delegate the results to other effects in the same stack:</p>
<ul>
<li><code class="prettyprint">State</code> for maintaining the map of values</li>
<li><code class="prettyprint">Writer</code> for logging</li>
<li><code class="prettyprint">Either[E, *]</code> for type errors
<p/></li>
</ul>
<pre><code class="prettyprint">  import org.atnos.eff._
  import org.atnos.eff.either._
  import org.atnos.eff.writer._
  import org.atnos.eff.state._
  import org.atnos.eff.interpret._
  import cats.implicits._
  import cats.data._

  type _writerString[R] = Writer[String, *] |= R
  type _stateMap[R] = State[Map[String, Any], *] |= R

  /**
 * Safe interpreter for KVStore effects
 *
 * It uses the following effects:
 *
 *  - Writer to create log statements
 *  - State to update a key-value Map
 *  - Either to raise errors if the type of an object in the map is not of the expected type
 *
 *  The resulting effect stack is U which is R without the KVStore effects
 *
 *  Note that we just require the Throwable, Writer and State effects to
 *  be able to be created in the stack U
 *
 * This interpreter uses the org.atnos.eff.interpreter.translate method
 * translating one effect of the stack to other effects in the same stack
 *
 *
 * NOTE:
 * - It is really important for type inference that the effects for U are listed after those for R!
 *
 * Implicit member definitions will NOT be found with the following definition:
 *
 * def runKVStore[R, U :_throwableEither :_writerString :_stateMap, A](effects: Eff[R, A]) (
 *   implicit m: Member.Aux[KVStore, R, U]): Eff[U, A] = {
 *
 */
  def runKVStore[R, U, A](
    effects: Eff[R, A]
  )(implicit m: Member.Aux[KVStore, R, U], throwable: _throwableEither[U], writer: _writerString[U], state: _stateMap[U]): Eff[U, A] = {

    translate(effects)(new Translate[KVStore, U] {
      def apply[X](kv: KVStore[X]): Eff[U, X] =
        kv match {
          case Put(key, value) =&gt;
            for {
              _ &lt;- tell(s&quot;put($key, $value)&quot;)
              _ &lt;- modify((map: Map[String, Any]) =&gt; map.updated(key, value))
              r &lt;- fromEither(Either.catchNonFatal(()))
            } yield r

          case Get(key) =&gt;
            for {
              _ &lt;- tell(s&quot;get($key)&quot;)
              m &lt;- get[U, Map[String, Any]]
              r &lt;- fromEither(Either.catchNonFatal(m.get(key)))
            } yield r

          case Delete(key) =&gt;
            for {
              _ &lt;- tell(s&quot;delete($key)&quot;)
              _ &lt;- modify((map: Map[String, Any]) =&gt; map - key)
              r &lt;- fromEither(Either.catchNonFatal(()))
            } yield r
        }
    })
  }
</code></pre>
<p><code class="prettyprint">Eff</code> is just a recursive structure that can be seen as
sequence of operations producing other operations, with potentially
other effects. In this way it is similar to folding a <code class="prettyprint">List</code>.
We often use folds (e.g. <code class="prettyprint">foldRight</code>) to obtain a single
value from a list; this recurses over the structure, combining its
contents.</p>
<p>The idea behind an <code class="prettyprint">Eff</code> interpreter is exactly the same.
We “fold” the recursive structure by:</p>
<ul>
<li>consuming each operation</li>
<li>compiling the operation into a target language</li>
<li>computing next operation
<p/></li>
</ul>
<p>An important aspect of interpreters is stack-safety. An interpreter
evaluates each step of a computation on the stack then calls itself to
evaluate the other steps. The <code class="prettyprint">org.atnos.eff.interpreter</code>
object provides various methods helping you write a stack-safe
interpreter:</p>
<ul>
<li><p><code class="prettyprint">interpretUnsafe</code> makes you define a
<code class="prettyprint">SideEffect</code> trait to return a value <code class="prettyprint">X</code> from an
effect <code class="prettyprint">T[X]</code></p></li>
<li><p><code class="prettyprint">translate</code> makes you define a <code class="prettyprint">Translate</code>
trait to “translate” your effect into other effects in the same
stack</p></li>
<li><p>both are specialized version of <code class="prettyprint">interpret1</code> which
makes you define a <code class="prettyprint">Recurse</code> trait to either return a value
<code class="prettyprint">X</code> from an effect or produce another <code class="prettyprint">Eff</code>
computation</p></li>
</ul>
<h3 id="run-your-program">Run your program</h3>
<p>The final step is naturally running your program after interpreting
it to another <code class="prettyprint">Eff</code> value. We need to</p>
<ul>
<li>specify a concrete stack of effects containing the effect we want to
interpret <code class="prettyprint">Fx.fx1[KVStore]</code> (just one effect in the
stack)</li>
<li>call our interpreter to get a <code class="prettyprint">Eff[NoFx, A]</code> value</li>
<li>call a final <code class="prettyprint">run</code> to get an <code class="prettyprint">A</code> value
<p/></li>
</ul>
<p>Like this:</p>
<pre><code class="prettyprint">      import org.atnos.eff._, syntax.all._

// run the program with the unsafe interpreter
      runKVStoreUnsafe(program[Fx.fx1[KVStore]]).run</code></pre>
<p><code class="prettyprint">&gt; Some(14)</code></p>
<p>With the safe interpreter, the process is the same and we need to</p>
<ul>
<li>specify an effect stack definition with all the effects</li>
<li>call our “safe” interpreter</li>
<li>call interpreters for all the other effects, including the final
<code class="prettyprint">NoFx</code> effect with <code class="prettyprint">run</code>
<p/></li>
</ul>
<p>Like that:</p>
<pre><code class="prettyprint">      import org.atnos.eff._, syntax.all._
      import cats._, data._

// run the program with the safe interpreter
      type Stack = Fx.fx4[KVStore, Either[Throwable, *], State[Map[String, Any], *], Writer[String, *]]

      val (result, logs) =
        runKVStore(program[Stack]).runEither.evalState(Map.empty[String, Any]).runWriter.run

      (result.toString +: logs).mkString(&quot;\n&quot;)</code></pre>
<pre><code class="prettyprint">&gt; Right(Some(14))
put(wild-cats, 2)
get(wild-cats)
put(wild-cats, 14)
put(tame-cats, 5)
get(wild-cats)
delete(tame-cats)</code></pre>
<h3 id="add-some-syntax">Add some syntax</h3>
<p>It is nice to be able to “chain” <code class="prettyprint">run</code> methods with this
additional piece of syntax:</p>
<pre><code class="prettyprint">      implicit class KVStoreOps[R, A](effects: Eff[R, A]) {
        def runStore[U](implicit
          m: Member.Aux[KVStore, R, U],
          throwable: _throwableEither[U],
          writer: _writerString[U],
          state: _stateMap[U]
        ): Eff[U, A] =
          runKVStore(effects)
      }

      val (result, logs) =
        program[Stack].runStore.runEither.evalState(Map.empty[String, Any]).runWriter.run

      (result.toString +: logs).mkString(&quot;\n&quot;)</code></pre>
<pre><code class="prettyprint">&gt; Right(Some(14))
put(wild-cats, 2)
get(wild-cats)
put(wild-cats, 14)
put(tame-cats, 5)
get(wild-cats)
delete(tame-cats)</code></pre>
<h3 id="composing-adts-with-the-eff-monad">Composing ADTs with the Eff
monad</h3>
<p>Real world applications often time combine different algebras. The
typelevel set of effects <code class="prettyprint">R</code> in <code class="prettyprint">Eff[R, A]</code> lets
us compose different algebras in the context of <code class="prettyprint">Eff</code>.</p>
<p>Let’s see a trivial example of unrelated ADT’s getting composed that
can form a more complex program. First you define your ADTs with smart
constructors:</p>
<pre><code class="prettyprint">  import org.atnos.eff._
  import all._

  sealed trait Interact[A]

  case class Ask(prompt: String) extends Interact[String]
  case class Tell(msg: String) extends Interact[Unit]

  type _interact[R] = Interact |= R

  def askUser[R: _interact](prompt: String): Eff[R, String] =
    send(Ask(prompt))

  def tellUser[R: _interact](message: String): Eff[R, Unit] =
    send(Tell(message))

  sealed trait DataOp[A]

  type _dataOp[R] = DataOp |= R

  case class AddCat(a: String) extends DataOp[Unit]
  case class GetAllCats() extends DataOp[List[String]]

  def addCat[R: _dataOp](a: String): Eff[R, Unit] =
    send(AddCat(a))

  def getAllCats[R: _dataOp]: Eff[R, List[String]] =
    send(GetAllCats())
</code></pre>
<p>Then you simply require your program to have <code class="prettyprint">MemberIn</code>
instances for those effects:</p>
<pre><code class="prettyprint">  import org.atnos.eff._

  def program[R: _interact: _dataOp]: Eff[R, Unit] =
    for {
      cat &lt;- askUser(&quot;What&#39;s the kitty&#39;s name?&quot;)
      _ &lt;- addCat(cat)
      cats &lt;- getAllCats
      _ &lt;- tellUser(&quot;Current cats: &quot; + cats.mkString(&quot;, &quot;))
    } yield ()</code></pre>
<p>Finally we write one interpreter per ADT:</p>
<pre><code class="prettyprint">  import cats._
  import cats.implicits._
  import org.atnos.eff._
  import interpret._

  def readLine(): String =
    &quot;snuggles&quot;

  def runInteract[R, A](effect: Eff[R, A])(implicit m: Interact &lt;= R): Eff[m.Out, A] =
    recurse(effect)(new Recurser[Interact, m.Out, A, A] {
      def onPure(a: A): A = a

      def onEffect[X](i: Interact[X]): X Either Eff[m.Out, A] = Left[X, Eff[m.Out, A]] {
        i match {
          case Ask(prompt) =&gt;
            println(prompt)
            readLine()

          case Tell(msg) =&gt;
            println(msg)
        }
      }

      def onApplicative[X, T[_]: Traverse](ms: T[Interact[X]]): T[X] Either Interact[T[X]] =
        Left(ms.map {
          case Ask(prompt) =&gt; println(prompt); readLine()
          case Tell(msg) =&gt; println(msg)
        })

    })(m)

  def runDataOp[R, A](effect: Eff[R, A])(implicit m: DataOp &lt;= R): Eff[m.Out, A] = {
    val memDataSet = new scala.collection.mutable.ListBuffer[String]

    recurse(effect)(new Recurser[DataOp, m.Out, A, A] {
      def onPure(a: A): A = a

      def onEffect[X](i: DataOp[X]): X Either Eff[m.Out, A] = Left[X, Eff[m.Out, A]] {
        i match {
          case AddCat(a) =&gt; memDataSet.append(a); ()
          case GetAllCats() =&gt; memDataSet.toList
        }
      }

      def onApplicative[X, T[_]: Traverse](ms: T[DataOp[X]]): T[X] Either DataOp[T[X]] =
        Left(ms.map {
          case AddCat(a) =&gt; memDataSet.append(a); ()
          case GetAllCats() =&gt; memDataSet.toList
        })
    })(m)

  }
</code></pre>
<p>Now if we run our program for a Stack combining both effects and type
in “snuggles” when prompted, we see something like this:</p>
<pre><code class="prettyprint">      type Stack = Fx.fx2[Interact, DataOp]

      runInteract(runDataOp(program[Stack])).run</code></pre>
<pre><code class="prettyprint">What&#39;s the kitty&#39;s name?
Current cats: snuggles</code></pre>
</div>

<script>
$(document).ready(function() {
  $('#tipue_search_input').tipuesearch({
    'show': 6
  });
});
</script>
</div>

</body>
</html>