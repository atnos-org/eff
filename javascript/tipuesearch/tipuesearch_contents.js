
var tipuesearch = {"pages": [{"title":"Eval", "text":"This effect is a very simple one. It allows the delayed execution of computations and it can serve as some sort of overall `IO` effect.Two methods are available to execute this effect: - `runEval: Eff[U, A]` to just execute the computations - `attemptEval: Eff[U, Throwable Either A]` to execute the computations but also catch any `Throwable` that would be thrownimport org.atnos.eff._, all._, syntax.all._      delay(1 + 1).runEval.run`> 2`", "tags":"", "loc":"org.atnos.site.lib.EvalEffectPage.html"},
{"title":"Option", "text":"Adding an `Option` effect in your stack allows to stop computations when necessary.If you create a value with `some(a)` this value will be used downstream but if you use `none` all computations will stop:import org.atnos.eff._, all._, syntax.all._      /** * Stack declaration */      type S = Fx.fx1[Option]// compute with this stack      val map: Map[String, Int] =        Map(\"key1\" -> 10, \"key2\" -> 20)// get 2 keys from the map and add the corresponding values      def addKeys(key1: String, key2: String): Eff[S, Int] = for {        a <- fromOption(map.get(key1))        b <- fromOption(map.get(key2))      } yield a + b      (addKeys(\"key1\", \"key2\").runOption.run, addKeys(\"key1\", \"missing\").runOption.run)`> (Some(30),None)`", "tags":"", "loc":"org.atnos.site.lib.OptionEffectPage.html"},
{"title":"Either", "text":"The `Either` effect is similar to the `Option` effect but adds the possibility to specify why a computation stopped: import org.atnos.eff._, all._, syntax.all._      /** Stack declaration   */      type S = Fx.fx1[Either[String, *]]      // compute with this stack      val map: Map[String, Int] =        Map(\"key1\" -> 10, \"key2\" -> 20)      // get 2 keys from the map and add the corresponding values      def addKeys(key1: String, key2: String): Eff[S, Int] = for {        a <- optionEither(map.get(key1), s\"'$key1' not found\")        b <- optionEither(map.get(key2), s\"'$key2' not found\")      } yield a + b      (addKeys(\"key1\", \"key2\").runEither.run, addKeys(\"key1\", \"missing\").runEither.run)`> (Right(30),Left('missing' not found))`*Note*: the `*` syntax comes from the [kind-projector](https://github.com/typelevel/kind-projector) project and allows us to avoidtype lambdas.A `catchLeft` method can also be used to intercept an error and possibly recover from it:      case class TooBig(value: Int)      type E = Fx.fx1[Either[TooBig, *]]      val i = 7      val value: Eff[E, Int] =        if (i > 5) left[E, TooBig, Int](TooBig(i))        else right[E, TooBig, Int](i)      val action: Eff[E, Int] = catchLeft[E, TooBig, Int](value) { case TooBig(k) =>        if (k < 10) right[E, TooBig, Int](k)        else left[E, TooBig, Int](TooBig(k))      }      action.runEither.run ==== Right(7)*Note*: the type annotations on `left` and `right` can be avoided by adding an implicit declaration in scope. You can learnmore about this in the  section.", "tags":"", "loc":"org.atnos.site.lib.EitherEffectPage.html"},
{"title":"Validate", "text":"The `Validate` effect is similar to the `Either` effect but let you accumulate failures: import org.atnos.eff._, all._, syntax.all._      /** Stack declaration   */      type S = Fx.fx1[Validate[String, *]]      def checkPositiveInt(i: Int): Eff[S, Unit] =        validateCheck(i >= 0, s\"$i is not positive\")      def checkPositiveInts(a: Int, b: Int, c: Int): Eff[S, (Int, Int, Int)] = for {        _ <- checkPositiveInt(a)        _ <- checkPositiveInt(b)        _ <- checkPositiveInt(c)      } yield (a, b, c)      checkPositiveInts(1, -3, -2).runNel.run`> Left(NonEmptyList(-3 is not positive, -2 is not positive))`", "tags":"", "loc":"org.atnos.site.lib.ValidateEffectPage.html"},
{"title":"Error", "text":"The `Error` effect is both an `Eval` effect and a `Either` one with `Throwable Either F` on the \"left\" side.  The idea is to represent computations which can fail, either with an exception or a failure. You can:  - create delayed computations with `ok`- fail with `fail(f: F)` where `F` is the failure type- throw an exception with `exception`Other useful combinators are available:  - `andFinally(last)` registers an action to be executed even in case of an exception or a failure- `orElse` runs an action and then run another one if the first is not successful- `whenFailed` does the same thing than `orElse` but uses the error for `action1` to decide which action to run nextWhen you run an `Error` effect you get back an `Error Either A` where `Error` is a type alias for `Throwable Either Failure`.  The `Error` object implements this effect with `String` as the `Failure` type but you are encouraged to create our own  failure datatype and extend the `Error[MyFailureDatatype]` trait.", "tags":"", "loc":"org.atnos.site.lib.ErrorEffectPage.html"},
{"title":"Reader", "text":"The `Reader` effect is used to request values from an \"environment\". The main method is `ask` to get the current environment(or \"configuration\" if you prefer to see it that way) and you can run an effect stack containing a `Reader` effect byproviding a value for the environment with the `runReader` method.You can also inject a \"local\" reader into a \"bigger\" one:import org.atnos.eff._, all._, syntax.all._      import cats.data._      case class Conf(host: String, port: Int)      type R1[A] = Reader[Int, A]      type R2[A] = Reader[Conf, A]      type S = Fx.fx2[R1, R2]      def getPort[R](implicit r: Reader[Int, *] |= R): Eff[R, String] = for {        p1 <- ask[R, Int]      } yield \"the port is \" + p1      getPort[S].translateReader((_: Conf).port).runReader(Conf(\"prod\", 80)).run`> the port is 80`", "tags":"", "loc":"org.atnos.site.lib.ReaderEffectPage.html"},
{"title":"Writer", "text":"You can then define your own custom `Fold` to log the values to a file:import org.atnos.eff._, all._, syntax.all._      import cats.data.Writer      import java.io.PrintWriter      import scala.io      type S = Fx.fx1[Writer[String, *]]      val action: Eff[S, Int] = for {        a <- pure[S, Int](1)        _ <- tell(\"first value \" + a)        b <- pure[S, Int](2)        _ <- tell(\"second value \" + b)      } yield a + b// define a fold to output values      def fileFold(path: String) = new RightFold[String, Unit] {        type S = PrintWriter        val init: S = new PrintWriter(path)        def fold(a: String, s: S): S = { s.println(a); s }        def finalize(s: S): Unit =          s.close      }      action.runWriterFold(fileFold(\"target/log\")).run      io.Source.fromFile(\"target/log\").getLines().toList`> List(second value 2, first value 1)`", "tags":"", "loc":"org.atnos.site.lib.WriterEffectPage.html"},
{"title":"State", "text":"A `State` effect can be seen as the combination of both a `Reader` and a `Writer` with these operations: - `get` get the current state - `put` set a new stateLet's see an example showing that we can also use tags to track different states at the same time:import cats.data._      import org.atnos.eff._, all._, syntax.all._      type S1[A] = State[Int, A]      type S2[A] = State[String, A]      type S = Fx.fx2[S1, S2]      val swapVariables: Eff[S, String] = for {        v1 <- get[S, Int]        v2 <- get[S, String]        _ <- put[S, Int](v2.size)        _ <- put[S, String](v1.toString)        w1 <- get[S, Int]        w2 <- get[S, String]      } yield \"initial: \" + (v1, v2).toString + \", final: \" + (w1, w2).toString      swapVariables.evalState(10).evalState(\"hello\").run`> initial: (10,hello), final: (5,10)`In the example above we have used an `eval` method to get the `A` in `Eff[R, A]` but it is also possible to get both the value and the state with `run` or only the state with `exec`.Instead of tagging state effects it is also possible to transform a State effect acting on a \"small\" state into a Stateeffect acting on a \"bigger\" state:import org.atnos.eff._, all._, syntax.all._      import cats.data.State      type Count[A] = State[Int, A]      type Sum[A] = State[Int, A]      type Mean[A] = State[(Int, Int), A]      type S1 = Fx.fx1[Count]      type S2 = Fx.fx1[Sum]      type S = Fx.fx1[Mean]      def count(list: List[Int]): Eff[S1, String] = for {        _ <- put(list.size)      } yield s\"there are ${list.size} values\"      def sum(list: List[Int]): Eff[S2, String] = {        val s = if (list.isEmpty) 0 else list.sum        for {          _ <- put(s)        } yield s\"the sum is $s\"      }      def mean(list: List[Int]): Eff[S, String] = for {        m1 <- count(list).lensState((_: (Int, Int))._1, (s: (Int, Int), i: Int) => (i, s._2))        m2 <- sum(list).lensState((_: (Int, Int))._2, (s: (Int, Int), i: Int) => (s._1, i))      } yield m1 + \"\n\" + m2      mean(List(1, 2, 3)).runState((0, 0)).run> (there are 3 valuesthe sum is 6,(3,6))", "tags":"", "loc":"org.atnos.site.lib.StateEffectPage.html"},
{"title":"List", "text":"The `List` effect is used for computations which may return several values.A simple example using this effect would be import org.atnos.eff._, all._, syntax.all._      type S = Fx.fx1[List]// create all the possible pairs for a given list// where the sum is greater than a value      def pairsBiggerThan[R: _list](list: List[Int], n: Int): Eff[R, (Int, Int)] = for {        a <- values(list: _*)        b <- values(list: _*)        found <-          if (a + b > n) singleton((a, b))          else empty      } yield found      pairsBiggerThan[S](List(1, 2, 3, 4), 5).runList.run`> List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))`", "tags":"", "loc":"org.atnos.site.lib.ListEffectPage.html"},
{"title":"Choose", "text":"The `Choose` effect is used for non-deterministic computations. With the `Choose` effect you can model computations which either:  - return no result at all  - choose between 2 different computations`Choose` is actually a generalization of `List` where instead of \"exploring\" all the branches we might \"cut\" some of them.That behaviour is controlled by the `Alternative[F]` instance you use when running `Choose`.For example if we take `List` to run a similar example as before, we get the list of all the accepted pairs: import org.atnos.eff._, all._, syntax.all._      type S = Fx.fx1[Choose]// create all the possible pairs for a given list// where the sum is greater than a value      def pairsBiggerThan[R: _choose](list: List[Int], n: Int): Eff[R, (Int, Int)] = for {        a <- chooseFrom(list)        b <- chooseFrom(list)        found <-          if (a + b > n) EffMonad[R].pure((a, b))          else zero      } yield found      import cats.instances.list._      pairsBiggerThan[S](List(1, 2, 3, 4), 5).runChoose.run`> List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))`", "tags":"", "loc":"org.atnos.site.lib.ChooseEffectPage.html"},
{"title":"Memo", "text":"The Memo effect allows the caching of expensive computations. Computations are \"stored\" with a given key, so that the nextcomputation with the same key will return the previously computed value. When interpreting those computations a `Cache` mustbe provided: import cats.Eval      import cats.syntax.all._      import org.atnos.eff._, memo._      import org.atnos.eff.syntax.memo._      import org.atnos.eff.syntax.eval._      import org.atnos.eff.syntax.eff._      type S = Fx.fx2[Memoized, Eval]      var i = 0      def expensive[R: _memo]: Eff[R, Int] =        memoize(\"key\", { i += 1; 10 * 10 })      (expensive[S] >> expensive[S]).runMemo(ConcurrentHashMapCache()).runEval.run === 100      \"there is only one invocation\" <==> (i === 1)`> there is only one invocation <=> true`There are 2 cache implementations provided in this library to support the Memo effect: - `org.atnos.eff.ConcurrentHashMapCache`: backed by a `java.util.concurrent.ConcurrentHashMap` where the keys are hashcodes for the keys used to memoize the values. This cache is thread-safe but unbounded so use with care! - `org.atnos.eff.ConcurrentWeakIdentityHashMapCache`: backed by a `ConcurrentWeakIdentityHashMap` where the keys are `System.identityHashCode`   for the keys used to memoize the values. This cache is thread-safe and uses weak references which can be garbage collected when   necessary.You can also use other, and better, cache implementations like [Caffeine](https://github.com/ben-manes/caffeine) to get more functionalitieslike eviction policies, maximum size and so on. You will need to implement the `Cache` interface for thisscalatrait Cache {  def memo[V](key: AnyRef, value: =>V): V}", "tags":"", "loc":"org.atnos.site.lib.MemoEffectPage.html"},
{"title":"TimedFuture", "text":"The `TimedFuture` effect is a thin shim on top of Scala's `Future`. The only extra capability it has built-in istimeouts, which are supported by passing in a `ScheduledExecutionContext`.Note that because `Future` represents a computation already taking place, `TimedFuture` is a function that returns a `Future`.This means if you start a computation before passing the `Future` into Eff, the `Future` will begin less predictably.Now, let's create some `TimedFuture` effects:import org.atnos.eff._      import org.atnos.eff.future._      import org.atnos.eff.syntax.all._      import org.atnos.eff.concurrent.Scheduler      import scala.concurrent._, duration._      import scala.concurrent.ExecutionContext.Implicits.global      type R = Fx.fx2[TimedFuture, Option]      val action: Eff[R, Int] =        for {          // create a value now          a <- Eff.pure[R, Int](1)          // evaluate a value later, on some other thread pool, and continue when it's finished          b <- futureDelay[R, Int](1)        } yield bThen we need to pass a `Scheduler` and an `ExecutionContext` in to begin the computation.      implicit val scheduler: Scheduler = ExecutorServices.schedulerFromGlobalExecutionContext      import org.atnos.eff.syntax.future._      Await.result(action.runOption.runSequential, 1.second)`> Some(1)`You can also use other `Future` or `Task` effects: - `twitter`: depend on `eff-twitter` and import `org.atnos.eff.addon.twitter.future._` - `monix`: depend on `eff-monix` and import `org.atnos.eff.addon.monix.task._`There are corresponding syntax imports to be able to call `runAsync` methods in: - `twitter`: `org.atnos.eff.syntax.addon.twitter.future._` - `monix`: `org.atnos.eff.syntax.addon.monix.task._``Future` and `Task` computations can also be memoized to avoid expensive computations to be done several times. You can either - use the `futureMemo/taskMemo` operator with a (mutable) cache - use the `futureMemoized/taskMemoized` operator with the `Memoized` effect (you will need to provide the cache later)<p/>import cats.syntax.all._      import org.atnos.eff._, future._, all._      import org.atnos.eff.concurrent.Scheduler      import org.atnos.eff.syntax.all._      import org.atnos.eff.syntax.future._      import scala.concurrent._, duration._      import scala.concurrent.ExecutionContext.Implicits.global      var i = 0      def expensive[R: _Future: _memo]: Eff[R, Int] =        futureMemoized[R, Int](\"key\", futureDelay[R, Int] { i += 1; 10 * 10 })      type S = Fx.fx2[Memoized, TimedFuture]      implicit val scheduler: Scheduler = ExecutorServices.schedulerFromGlobalExecutionContext      val futureMemo: Future[Int] =        (expensive[S] >> expensive[S]).runFutureMemo(ConcurrentHashMapCache()).runSequential      Await.result(futureMemo, 1.second)      \"there is only one invocation\" <==> (i === 1)`> there is only one invocation <=> true`", "tags":"", "loc":"org.atnos.site.lib.TimedFutureEffectPage.html"},
{"title":"Task", "text":"The `Task` effect is a thin shim on top of Monix's `Task`. This effect is not bundled in core Eff and requiresthe `eff-monix` extension to use.Now, let's create some `Task` effects:import org.atnos.eff._      import org.atnos.eff.addon.monix.task._      import org.atnos.eff.syntax.addon.monix.task._      import monix.eval.Task      type R = Fx.fx2[Task, Option]      val action: Eff[R, Int] =        for {          // create a value now          a <- Eff.pure[R, Int](1)          // evaluate a value later, on the thread pool specified by a Monix `Scheduler`, and continue when it's finished          b <- taskDelay[R, Int](1)        } yield bThen we need to pass a Monix `Scheduler`  in to begin the computation.      implicit val scheduler =        monix.execution.Scheduler(ExecutionContext.fromExecutorService(Executors.newScheduledThreadPool(10)): ExecutionContext)Monix doesn't natively offer an Await API to block on a Task result.Instead it advises converting to a Scala `Future` and using `Await.result`.See https://monix.io/docs/2x/eval/task.html#blocking-for-a-result      import scala.concurrent.Await      Await.result(action.runOption.runAsync.runToFuture, 1.second)`> Some(1)`", "tags":"", "loc":"org.atnos.site.lib.TaskEffectPage.html"},
{"title":"Safe", "text":"The Safe effect is useful to handle resources which must be closed even in the presence of exceptions. The mainoperations are - `finally` to create an action which must always be executed after another one, even if the first one fails - `catchThrowable` to handle a thrown exception - `bracket(open)(step)(close)` to open a resource, use it and then close it safely. The `close` part is a \"finalizer\"<p/>Let's see an example for the protection of a resource: import org.atnos.eff.syntax.all._      import org.atnos.eff._, all._// let's represent a resource which can be in use      case class Resource(values: List[Int] = (1 to 10).toList, inUse: Boolean = false) {        def isClosed = !inUse      }      var resource = Resource()// our stack of effects, with safe evaluation      type S = Fx.fx1[Safe]      def openResource: Eff[S, Resource] =        protect { resource = resource.copy(inUse = true); resource }      def closeResource(r: Resource): Eff[S, Unit] =        protect { resource = r.copy(inUse = false) }      def useResource(ok: Boolean) = (r: Resource) => protect[S, Int](if (ok) r.values.sum else throw new Exception(\"boo\"))// this program uses the resource safely even if there is an exception      def program(ok: Boolean): (Throwable Either Int, List[Throwable]) =        bracket(openResource)(useResource(ok))(closeResource).runSafe.run> ResultsWithout exception: Right(55), finalizers exceptions: no exceptions,	resource is closed: trueWith exception   : Left(boo), finalizers exceptions: no exceptions,	resource is closed: trueAs you can see in the signature of `program` the return value of `runSafe` is `(Throwable Either A, List[Throwable])`.The first part is the result of your program, which may end with an exception, and the second part is the list ofpossible exceptions thrown by the finalizers which can themselves fail.A simpler version of `bracket` is `finally`.This example show how to use `finally` but also what happens if a finalizer fails:import org.atnos.eff.syntax.all._      import org.atnos.eff._, all._// our stack of effects, with safe evaluation      type S = Fx.fx1[Safe]      var sumDone: Boolean = false      def setDone(ok: Boolean): Eff[S, Unit] =        protect[S, Unit](if (ok) sumDone = true else throw new Exception(\"failed!!\"))// this program tries to set sumDone to true when the computation is done      def program(ok: Boolean, finalizeOk: Boolean): (Throwable Either Int, List[Throwable]) =        (protect[S, Int](if (ok) (1 to 10).sum else throw new Exception(\"boo\")) `finally` setDone(finalizeOk)).runSafe.run> ResultsComputation ok, finalizer ok: Right(55), finalizers exceptions: no exceptionsComputation ok, finalizer ko: Right(55), finalizers exceptions: List(failed!!)Computation ko, finalizer ok: Left(boo), finalizers exceptions: no exceptionsComputation ko, finalizer ko: Left(boo), finalizers exceptions: List(failed!!)Finally (no pun intended!) note that you can use `execSafe` if you are not interested in the result of the finalizers.", "tags":"", "loc":"org.atnos.site.lib.SafeEffectPage.html"},
{"title":"Installation", "text":"You add `eff` as an sbt dependency:scalalibraryDependencies += \"org.atnos\" %% \"eff\" % \"7.0.1-SNAPSHOT\"// to write types like Reader[String, *]libraryDependencies ++= {  if (scalaBinaryVersion.value == \"3\") {    Nil  } else {    Seq(compilerPlugin(\"org.typelevel\" %% \"kind-projector\" % \"0.13.2\" cross CrossVersion.full))  }}scalacOptions ++= {  if (scalaBinaryVersion.value == \"3\") {    Seq(\"-Ykind-projector\")  } else {    Nil  }}To get types like `Reader[String, *]` (with more than one type parameter) correctly inferred, you'll have to use the following compiler optionscalascalacOptions ++= {  if (scalaBinaryVersion.value == \"2.12\") {    Seq(\"-Ypartial-unification\")  } else {    Nil  }} Additional dependenciesThis table lists the other available eff modules: Name              | Functionality ----------------- | ---------------------------------------------------- `eff-scalaz`      | if you want to use [Scalaz](https://github.com/scalaz/scalaz) as a library for functional programming. This gives you a `Scalaz` `Monad` instance for `Eff` and a Scalaz's `\/` effect `eff-monix`       | to use Monix's `Task` effect `eff-cats-effect` | to use cats's `IO` effect `eff-twitter`     | to use Twitter's `Future` effect `eff-doobie`      | to use Doobie's `ConnectionIO` effect<p/> Imports Main typesThe main `eff` types: `Eff`, `Member`, `Fx` are accessible in the `org.atnos.eff` package:scalaimport org.atnos.eff._Many other effects are also available . Creating effectsThe functions used to create effects are grouped under different objects named after the effect type. For example if you want to create the `Eval` effect you need toimport:scalaimport org.atnos.eff.eval._You can also import most of the effects at once with:scalaimport org.atnos.eff.all._The only effects not included in the previous import are: - the `Error` effect. This effect requires a type parameter representing the \"failure\" type and must be provided by the user of the library - the `Future` effect. This effect shares some operations like `runAsync` with other \"async\" effects like monix's `TaskEffect`    and the import could clash with `import org.atnos.eff.addon.monix.task._` Interpreting effectsInterpreting effects usually requires some syntax to \"run\" a given effect. For example to \"run\" the `Option` effect you will import:scala// to create the effectimport org.atnos.eff.option._// to access the runOption methodimport org.atnos.eff.syntax.option._fromOption(Option(1)).runOptionYou can also access all the syntax imports at once with:scalaimport org.atnos.eff.syntax.all._ Intellij supportIntellij error highlighting doesn't support implicit-directed type inference yet, check https://youtrack.jetbrains.com/issue/SCL-11140 or https://youtrack.jetbrains.com/issue/SCL-10753 for progress. With ScalazIf you use Scalaz as your functional programming library you might need additional imports in order to use some creationmethods specific to Scalaz. For example:scalaimport org.atnos.eff.addon.scalaz.either._fromDisjunction(\/-(1))There is also an `all` object importing all those methods at once:scalaimport org.atnos.eff.addon.scalaz.all._fromDisjunction(\/-(1))And you can already guess, there are some syntax imports following the same pattern:scalaimport org.atnos.eff.addon.scalaz.either._import org.atnos.eff.addon.scalaz.syntax.either._fromDisjunction(\/-(1)).runDisjunction", "tags":"", "loc":"org.atnos.site.Installation.html"},
{"title":"Introduction", "text":"Extensible effects are an alternative to monad transformers for computing with effects in a functional way.This library uses a \"free-er\" monad and extensible effects to create an \"effect stack\" as described in[Oleg Kiselyov's paper](https://okmij.org/ftp/Haskell/extensible/more.pdf).There are lots of advantages to this approach: - operations can be declared as \"requiring\" an effect, without the need to fix the full stack of effects in advance - effects handlers are modular and can be replaced with other implementations as needed (even at runtime) - the underlying implementation is performant and stack-safe - existing monadic datatypes can be integrated to the library - effect stacks can be modified or combinedThis is probably very abstract so let's see more precisely what this all means. First example*Please make sure you have done all the setup described on the  page first*A monadic action is modelled as a value of type `Eff[R, A]` where `R` denotes a set of effects and `A` is the valuereturned by the computation, possibly triggering some effects when evaluated.The effects `R` are modelled by a type-level list of \"effect constructors\", for example:import cats._, data._      import org.atnos.eff._      type ReaderInt[A] = Reader[Int, A]      type WriterString[A] = Writer[String, A]      type Stack = Fx.fx3[WriterString, ReaderInt, Eval]The stack `Stack` above declares 3 effects: - a `ReaderInt` effect to access some configuration number of type `Int` - a `WriterString` effect to log string messages - an `Eval` effect to only compute values on demand (a bit like lazy values)Now we can write a program with those 3 effects, using the primitive operations provided by `ReaderEffect`, `WriterEffect` and `EvalEffect`:import org.atnos.eff.all._      import org.atnos.eff.syntax.all._// useful type aliases showing that the ReaderInt and the WriterString effects are \"members\" of R// note that R could have more effects      type _readerInt[R] = ReaderInt |= R      type _writerString[R] = WriterString |= R      def program[R: _readerInt: _writerString: _eval]: Eff[R, Int] = for {        // get the configuration        n <- ask[R, Int]        // log the current configuration value        _ <- tell(\"the required power is \" + n)        // compute the nth power of 2        a <- delay(math.pow(2, n.toDouble).toInt)        // log the result        _ <- tell(\"the result is \" + a)      } yield a// run the action with all the interpreters// each interpreter running one effect      program[Stack].runReader(6).runWriter.runEval.run`> (64,List(the required power is 6, the result is 64))`As you can see, all the effects of the `Stack` type are being executed one by one: 1. the `Reader` effect, which provides a value, `6`, to each computation needing it 2. the `Writer` effect, which logs messages 3. the `Eval` effect to compute the \"power of 2 computation\" 4. `run` extracts the final result<br/>Maybe you noticed that the effects are not being executed in the same order as their order in the stack declaration.The effects can indeed be executed in any order. This doesn't mean though that the results will be the same. For examplerunning the `Writer` effect then `Either` effect returns `String Either (A, List[String])` whereas running the `Either` effect then the `Writer` effect returns `(String Either A, List[String])`.This all works thanks to some implicits definitions guiding Scala type inference towards theright return types. You can learn more on implicits in the  section.You can now get a more detailed presentation of the use of the Eff monad by reading the  oryou can learn about  supported by this library.", "tags":"", "loc":"org.atnos.site.Introduction.html"},
{"title":"Out of the box", "text":"This library comes with the following effects: Name                | Description                                                                      | Link ---------           | -------------------------------------------                                      | ----- `EvalEffect`        | an effect for delayed computations                                               |  `OptionEffect`      | an effect for optional computations, stopping when there's no available value    |  `EitherEffect`      | an effect for computations with failures, stopping when there is a failure       |  `ValidateEffect`    | an effect for computations with failures, allowing to collect failures           |  `ErrorEffect`       | a mix of Eval and Either, catching exceptions and returning them as failures     |  `ReaderEffect`      | an effect for depending on a configuration or an environment                     |  `WriterEffect`      | an effect to log messages                                                        |  `StateEffect`       | an effect to pass state around                                                   |  `ListEffect`        | an effect for computations returning several values                              |  `ChooseEffect`      | an effect for modeling non-determinism                                           |  `MemoEffect`        | an effect for memoizing values                                                   |  `FutureEffect`      | an effect for asynchronous computations                                          |  `TaskEffect`        | an effect for asynchronous computations using Monix Tasks                        |  `SafeEffect`        | an effect for guaranteeing resource safety                                       | <small>(from `org.atnos.eff._`)</small>Other modules listed in  provide additional effects (Twitter Future, Scalaz Task, Doobie ConnectionIO,...).<br/> What's next?Now you can learn how to  !", "tags":"", "loc":"org.atnos.site.OutOfTheBox.html"},
{"title":"Tutorial", "text":"This tutorial is intentionally structured like the [Free monad tutorial for cats](https://typelevel.org/cats/datatypes/freemonad.html) so that a side-by-side comparison of the 2 approaches is possible. Study your topicLet's imagine that we want to create a DSL for a key-value store. We want to be able to do three things with keys:  - put a value into the store, associated with its key.  - get a value from the store given its key.  - delete a value from the store given its key.<p/>The idea is to write a sequence of these operations in the embedded DSL as a \"program\",interpret the \"program\", and finally execute the \"program\" to interact with the actual key-value store.For example: put(\"toto\", 3) get(\"toto\") // returns 3 delete(\"toto\")But we want: - the computation to be represented as a pure, immutable value - to separate the creation and execution of the program - to be able to support many different methods of execution Create an ADT representing your grammarADT stands for \"Algebraic Data Type\". In this context, it refers to a closed set of types which can be combined tobuild up complex, recursive values.We need to create an ADT to represent our key-value operations: // the type parameter A can be read as the type of value returned by the operation  sealed trait KVStore[+A]  case class Put[T](key: String, value: T) extends KVStore[Unit]  case class Get[T](key: String) extends KVStore[Option[T]]  case class Delete(key: String) extends KVStore[Unit] Free your ADTThere are four basic steps to \"freeing\" the ADT: 1. Create smart constructors for `KVStore[_]` using `Eff.send` 1. Build a program out of key-value DSL operations 1. Build an interpreter for programs of DSL operations 1. Execute our interpreted program 1. [optional] add some syntax for the interpreter Create smart constructors using `Eff.send`These methods will let you create `Eff` values for your key-value store \"Effect\":  import org.atnos.eff._// T |= R is an alias for MemberIn[T, R]// stating that effects of type T[_] can be injected in the effect stack R// It is also equivalent to MemberIn[KVStore, R]  type _kvstore[R] = KVStore |= R  /** store returns nothing (i.e. Unit) */  def store[T, R: _kvstore](key: String, value: T): Eff[R, Unit] =    Eff.send[KVStore, R, Unit](Put(key, value))  /** find returns a T value if the key exists */  def find[T, R: _kvstore](key: String): Eff[R, Option[T]] =    Eff.send[KVStore, R, Option[T]](Get(key))  /** delete returns nothing (i.e. Unit) */  def delete[T, R: _kvstore](key: String): Eff[R, Unit] =    Eff.send(Delete(key))  /** update composes get and put, and returns nothing. */  def update[T, R: _kvstore](key: String, f: T => T): Eff[R, Unit] =    for {      ot <- find[T, R](key)      _ <- ot.map(t => store[T, R](key, f(t))).getOrElse(Eff.pure(()))    } yield ()Each method requires the `KVStore` effect to be a member of an \"effect stack\" `R`. The return values are of type `Eff[R, A]` where `R` is a stack of effects possibly containing other effects than key-value store operations and yielding values of type `A`. Build a programNow that we can construct values with `KVStore` effects we can use our DSL to write \"programs\" using a for-comprehension:   import org.atnos.eff._  def program[R: _kvstore]: Eff[R, Option[Int]] =    for {      _ <- store(\"wild-cats\", 2)      _ <- update[Int, R](\"wild-cats\", _ + 12)      _ <- store(\"tame-cats\", 5)      n <- find[Int, R](\"wild-cats\")      _ <- delete(\"tame-cats\")    } yield nThis looks like a monadic flow. However, it just builds a recursive data structure representing the sequence of operations. Write an interpreter for your programAs you may have understood now, `Eff` is used to create an embedded DSL. By itself, this DSL only represents a sequence of operations (defined by a recursive data structure); it doesn't produce anything.`Eff` is a programming language inside your programming language!So, like any other programming language, we need to interpret our abstract language into concrete values.To do this, we will use an interpreter transforming our `KVStore` effects using a simple mutable map:   import org.atnos.eff._  import interpret._  import cats.Traverse  import cats.syntax.all._  import scala.collection.mutable._  /** * Unsafe interpreter for KVStore effects * * the program will crash if a type is incorrectly specified. * * The interpreter requires the KVStore effect to be a Member of R (with <=) * Meaning that we can statically know the resulting type once we have removed * KVStore from R, and this type is m.Out. * * The interpreter uses the `interpretUnsafe` method from `org.atnos.eff.Interpreter` to implement a * stack-safe interpretation of effects as a side-effect. * * `interpretUnsafe` needs the definition of a side-effect where * we get each `KVStore[X]` effect, run side-effects and return a value `X`. * * The resulting effect stack is m.Out which is R without the KVStore effects * */  def runKVStoreUnsafe[R, A](effects: Eff[R, A])(implicit m: KVStore <= R): Eff[m.Out, A] = {    // a very simple (and imprecise) key-value store    val kvs = Map.empty[String, Any]    val sideEffect = new SideEffect[KVStore] {      def apply[X](kv: KVStore[X]): X =        kv match {          case Put(key, value) =>            println(s\"put($key, $value)\")            kvs.put(key, value)            ()          case Get(key) =>            println(s\"get($key)\")            kvs.get(key)          case Delete(key) =>            println(s\"delete($key)\")            kvs.remove(key)            ()        }      def applicative[X, Tr[_]: Traverse](ms: Tr[KVStore[X]]): Tr[X] =        ms.map(apply)    }    interpretUnsafe(effects)(sideEffect)(m)  }Please note this interpreter is impure -- it mutates `kvs` and also produces logging output using `println`.The whole purpose of functional programming isn't to prevent side-effects, it is just to push side-effects to theboundaries of your system in a well-known and controlled way.We can also interpret `KVStore` effects differently and delegate the results to other effects in the same stack: - `State` for maintaining the map of values - `Writer` for logging - `Either[E, *]` for type errors<p/>  import org.atnos.eff._  import org.atnos.eff.either._  import org.atnos.eff.writer._  import org.atnos.eff.state._  import org.atnos.eff.interpret._  import cats.syntax.all._  import cats.data._  type _writerString[R] = Writer[String, *] |= R  type _stateMap[R] = State[Map[String, Any], *] |= R  /** * Safe interpreter for KVStore effects * * It uses the following effects: * *  - Writer to create log statements *  - State to update a key-value Map *  - Either to raise errors if the type of an object in the map is not of the expected type * *  The resulting effect stack is U which is R without the KVStore effects * *  Note that we just require the Throwable, Writer and State effects to *  be able to be created in the stack U * * This interpreter uses the org.atnos.eff.interpreter.translate method * translating one effect of the stack to other effects in the same stack * * * NOTE: * - It is really important for type inference that the effects for U are listed after those for R! * * Implicit member definitions will NOT be found with the following definition: * * def runKVStore[R, U :_throwableEither :_writerString :_stateMap, A](effects: Eff[R, A]) ( *   implicit m: Member.Aux[KVStore, R, U]): Eff[U, A] = { * */  def runKVStore[R, U, A](    effects: Eff[R, A]  )(implicit m: Member.Aux[KVStore, R, U], throwable: _throwableEither[U], writer: _writerString[U], state: _stateMap[U]): Eff[U, A] = {    translate(effects)(new Translate[KVStore, U] {      def apply[X](kv: KVStore[X]): Eff[U, X] =        kv match {          case Put(key, value) =>            for {              _ <- tell(s\"put($key, $value)\")              _ <- modify((map: Map[String, Any]) => map.updated(key, value))              r <- fromEither(Either.catchNonFatal(()))            } yield r          case Get(key) =>            for {              _ <- tell(s\"get($key)\")              m <- get[U, Map[String, Any]]              r <- fromEither(Either.catchNonFatal(m.get(key)))            } yield r          case Delete(key) =>            for {              _ <- tell(s\"delete($key)\")              _ <- modify((map: Map[String, Any]) => map - key)              r <- fromEither(Either.catchNonFatal(()))            } yield r        }    })  }`Eff` is just a recursive structure that can be seen as sequence of operations producing other operations, withpotentially other effects. In this way it is similar to folding a `List`. We often use folds (e.g. `foldRight`) to obtaina single value from a list; this recurses over the structure, combining its contents.The idea behind an `Eff` interpreter is exactly the same. We \"fold\" the recursive structure by: - consuming each operation - compiling the operation into a target language - computing next operation<p/>An important aspect of interpreters is stack-safety. An interpreter evaluates each step of a computation on the stackthen calls itself to evaluate the other steps. The `org.atnos.eff.interpreter` object provides various methods helping youwrite a stack-safe interpreter: - `interpretUnsafe` makes you define a `SideEffect` trait to return a value `X` from an effect `T[X]` - `translate` makes you define a `Translate` trait to \"translate\" your effect into other effects in the same stack - both are specialized version of `interpret1` which makes you define a `Recurse` trait to either return a value `X`   from an effect or produce another `Eff` computation Run your programThe final step is naturally running your program after interpreting it to another `Eff` value. We need to - specify a concrete stack of effects containing the effect we want to interpret `Fx.fx1[KVStore]` (just one effect in the stack) - call our interpreter to get a `Eff[NoFx, A]` value - call a final `run` to get an `A` value<p/>Like this:       import org.atnos.eff._, syntax.all._// run the program with the unsafe interpreter      runKVStoreUnsafe(program[Fx.fx1[KVStore]]).run`> Some(14)`With the safe interpreter, the process is the same and we need to - specify an effect stack definition with all the effects - call our \"safe\" interpreter - call interpreters for all the other effects, including the final `NoFx` effect with `run`<p/>Like that:       import org.atnos.eff._, syntax.all._      import cats._, data._// run the program with the safe interpreter      type Stack = Fx.fx4[KVStore, Either[Throwable, *], State[Map[String, Any], *], Writer[String, *]]      val (result, logs) =        runKVStore(program[Stack]).runEither.evalState(Map.empty[String, Any]).runWriter.run      (result.toString +: logs).mkString(\"\n\")> Right(Some(14))put(wild-cats, 2)get(wild-cats)put(wild-cats, 14)put(tame-cats, 5)get(wild-cats)delete(tame-cats) Add some syntaxIt is nice to be able to \"chain\" `run` methods with this additional piece of syntax:       implicit class KVStoreOps[R, A](effects: Eff[R, A]) {        def runStore[U](implicit          m: Member.Aux[KVStore, R, U],          throwable: _throwableEither[U],          writer: _writerString[U],          state: _stateMap[U]        ): Eff[U, A] =          runKVStore(effects)      }      val (result, logs) =        program[Stack].runStore.runEither.evalState(Map.empty[String, Any]).runWriter.run      (result.toString +: logs).mkString(\"\n\")> Right(Some(14))put(wild-cats, 2)get(wild-cats)put(wild-cats, 14)put(tame-cats, 5)get(wild-cats)delete(tame-cats) Composing ADTs with the Eff monadReal world applications often time combine different algebras. The typelevel set of effects `R` in `Eff[R, A]`lets us compose different algebras in the context of `Eff`.Let's see a trivial example of unrelated ADT's getting composed that can form a more complex program. First you defineyour ADTs with smart constructors:  import org.atnos.eff._  import all._  sealed trait Interact[A]  case class Ask(prompt: String) extends Interact[String]  case class Tell(msg: String) extends Interact[Unit]  type _interact[R] = Interact |= R  def askUser[R: _interact](prompt: String): Eff[R, String] =    send(Ask(prompt))  def tellUser[R: _interact](message: String): Eff[R, Unit] =    send(Tell(message))  sealed trait DataOp[A]  type _dataOp[R] = DataOp |= R  case class AddCat(a: String) extends DataOp[Unit]  case class GetAllCats() extends DataOp[List[String]]  def addCat[R: _dataOp](a: String): Eff[R, Unit] =    send(AddCat(a))  def getAllCats[R: _dataOp]: Eff[R, List[String]] =    send(GetAllCats())Then you simply require your program to have `MemberIn` instances for those effects:  import org.atnos.eff._  def program[R: _interact: _dataOp]: Eff[R, Unit] =    for {      cat <- askUser(\"What's the kitty's name?\")      _ <- addCat(cat)      cats <- getAllCats      _ <- tellUser(\"Current cats: \" + cats.mkString(\", \"))    } yield ()Finally we write one interpreter per ADT:  import cats._  import cats.syntax.all._  import org.atnos.eff._  import interpret._  def readLine(): String =    \"snuggles\"  def runInteract[R, A](effect: Eff[R, A])(implicit m: Interact <= R): Eff[m.Out, A] =    recurse(effect)(new Recurser[Interact, m.Out, A, A] {      def onPure(a: A): A = a      def onEffect[X](i: Interact[X]): X Either Eff[m.Out, A] = Left[X, Eff[m.Out, A]] {        i match {          case Ask(prompt) =>            println(prompt)            readLine()          case Tell(msg) =>            println(msg)        }      }      def onApplicative[X, T[_]: Traverse](ms: T[Interact[X]]): T[X] Either Interact[T[X]] =        Left(ms.map {          case Ask(prompt) => println(prompt); readLine()          case Tell(msg) => println(msg)        })    })(m)  def runDataOp[R, A](effect: Eff[R, A])(implicit m: DataOp <= R): Eff[m.Out, A] = {    val memDataSet = new scala.collection.mutable.ListBuffer[String]    recurse(effect)(new Recurser[DataOp, m.Out, A, A] {      def onPure(a: A): A = a      def onEffect[X](i: DataOp[X]): X Either Eff[m.Out, A] = Left[X, Eff[m.Out, A]] {        i match {          case AddCat(a) => memDataSet.append(a); ()          case GetAllCats() => memDataSet.toList        }      }      def onApplicative[X, T[_]: Traverse](ms: T[DataOp[X]]): T[X] Either DataOp[T[X]] =        Left(ms.map {          case AddCat(a) => memDataSet.append(a); ()          case GetAllCats() => memDataSet.toList        })    })(m)  }Now if we run our program for a Stack combining both effects and type in \"snuggles\" when prompted, we see something like this:      type Stack = Fx.fx2[Interact, DataOp]      runInteract(runDataOp(program[Stack])).runWhat's the kitty's name?Current cats: snuggles", "tags":"", "loc":"org.atnos.site.Tutorial.html"},
{"title":"Creating effects", "text":" CreationNew effects can be added to the library pretty easily. Let's create an Effect for a new \"optional\" type.We need: - a base type. We use a `Maybe` data type with 2 cases `Just` and `Nothing` - a method to send values of type `A` into `Eff[R, A]` - an interpreter  import cats._  import implicits._  import org.atnos.eff._  import all._  import org.atnos.eff.interpret._  sealed trait Maybe[A]  case class Just[A](a: A) extends Maybe[A]  case class Nothing[A]() extends Maybe[A]  object MaybeEffect {    type _maybe[R] = Maybe |= R    def just[R: _maybe, A](a: A): Eff[R, A] =      send[Maybe, R, A](Just(a))    def nothing[R: _maybe, A]: Eff[R, A] =      send[Maybe, R, A](Nothing())    def runMaybe[R, U, A, B](effect: Eff[R, A])(implicit m: Member.Aux[Maybe, R, U]): Eff[U, Option[A]] =      recurse(effect)(new Recurser[Maybe, U, A, Option[A]] {        def onPure(a: A) = Some(a)        def onEffect[X](m: Maybe[X]): X Either Eff[U, Option[A]] =          m match {            case Just(x) => Left(x)            case Nothing() => Right(Eff.pure(None))          }        def onApplicative[X, T[_]: Traverse](ms: T[Maybe[X]]): T[X] Either Maybe[T[X]] =          Right(ms.sequence)      })    implicit val applicativeMaybe: Applicative[Maybe] = new Applicative[Maybe] {      def pure[A](a: A): Maybe[A] = Just(a)      def ap[A, B](ff: Maybe[A => B])(fa: Maybe[A]): Maybe[B] =        (fa, ff) match {          case (Just(a), Just(f)) => Just(f(a))          case _ => Nothing()        }    }  }In the code above: - the `just` and `nothing` methods use `Eff.send` to \"send\" values into a larger sum of effects `Eff[R, A]` - `runMaybe` runs the `Maybe` effect by using the `interpret.recurse` and a `Recurser` to translate `Maybe` values into `Option` values Compiler limitationWhen you create an effect you can define a sealed trait and case classes to represent different possibilities for that effect.For example for interacting with a database you might create: trait DatabaseEffect {        case class Record(fields: List[String])        sealed trait Db[A]        case class Get[A](id: Int) extends Db[Record]        case class Update[A](id: Int, record: Record) extends Db[Record]      }It is recommended to create the `Db` types **outside** of the `DatabaseEffect` trait. Indeed, during `Member` implicit resolution,depending on how you import the `Db` effect type (if it is inherited from an object or not) you could experience compilercrashes :-(. InterpreterInterpreting a given effect generally means knowing what to do with a value of type `M[X]` where `M` is the effect. Ifthe interpreter can \"execute\" the effect: produce logs (`Writer`), execute asynchronously (`Future`), check the value (`Either`),...then extract a value `X`, then we can call a continuation to get the next effect and interpret it as well.The `org.atnos.eff.interpret` object offers several support traits and functions to write interpreters. In this example weuse a `Recurser` which will be used to \"extract\" a value `X` from `Maybe[X]` or just give up with `Eff.pure(None)`The `runMaybe` method needs an implicit `Member.Aux[Maybe, R, U]`. This must be read in the following way: - `Maybe` must be member of the effect stack `R` and its removal from `R` should be the effect stack `U`<br/>Then we can use this effect in a computation:import org.atnos.eff._      import org.atnos.eff.eff._      import MaybeEffect._      val action: Eff[Fx.fx1[Maybe], Int] =        for {          a <- just(2)          b <- just(3)        } yield a + b      run(runMaybe(action))`> Some(5)`----", "tags":"", "loc":"org.atnos.site.CreateEffects.html"},
{"title":"Transform stacks", "text":" What is an \"effect stack\"?There is an abuse of language here. The name \"stack\" comes from \"monad stack\" used when talking about monad transformers.With `Eff` though, effects are modelled differently, as a tree of effects.For example the type level representation of four effects `T1, T2, T3, T4` is represented as:Fx.fx4[T1, T2, T3, T4]// orFxAppend[  Fx1[T1],  Fx3[T2, T3, T4]]So every-time we manipulate effects at the type level we modify a tree of effects. For example, interpreting the effect `T3`would leave us with the tree:FxAppend[  Fx1[T1],  Fx2[T2, T4]]This code should prove it:// for now the following implicit summoning crashes the compiler      // val member_ : Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]] =      //  implicitly[Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]]]Unfortunately the compiler has some difficulties with it, so you can either get the member value by using the  implicit definitions \"manually\" or you can just summon the member instance without the `Aux` part:import org.atnos.eff._// so you need to explicitly define the implicit      val member_ : Member.Aux[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]], FxAppend[Fx1[T1], Fx2[T2, T4]]] =        Member.MemberAppendR(Member.Member3M)// but this works      val member: Member[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]]] =        implicitly[Member[T3, FxAppend[Fx1[T1], Fx3[T2, T3, T4]]]]More importantly the compiler is still able to track the right types resulting of the interpretation of a given effectso the following compiles ok:import org.atnos.eff._      def runT3[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T3, R, U]): Eff[U, A] = ???      def runT2[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T2, R, U]): Eff[U, A] = ???      def runT1[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T1, R, U]): Eff[U, A] = ???      def runT4[R, U, A](e: Eff[R, A])(implicit m: Member.Aux[T4, R, U]): Eff[U, A] = ???      type S = FxAppend[Fx1[T1], Fx3[T2, T3, T4]]      runT1(runT4(runT2(runT3(Eff.send[T3, S, Int](???))))) Transform an effect to another Change the effectA typical use case for this is to transform a stack having a `Reader[S, *]` effect to a stack having a `Reader[B, *]` effect where `S` is \"contained\" in `B` (meaning that there is a mapping from `B`, \"big\", to `S`, \"small\"). Here is an example:import org.atnos.eff._, all._      import org.atnos.eff.syntax.all._      import cats._      import cats.data._      case class Conf(host: String, port: Int)      type ReaderPort[A] = Reader[Int, A]      type ReaderHost[A] = Reader[String, A]      type ReaderConf[A] = Reader[Conf, A]      type S1 = Fx.fx2[ReaderHost, Option]      type S2 = Fx.fx2[ReaderPort, Option]      type SS = Fx.fx2[ReaderConf, Option]      val readHost: Eff[S1, String] = for {        c <- ask[S1, String]        h <- OptionEffect.some[S1, String](\"hello\")      } yield h      val readPort: Eff[S2, String] = for {        c <- ask[S2, Int]        h <- OptionEffect.some[S2, String](\"world\")      } yield h      val fromHost = new (ReaderHost ~> ReaderConf) {        def apply[X](r: ReaderHost[X]) = Reader((c: Conf) => r.run(c.host))      }      val fromPort = new (ReaderPort ~> ReaderConf) {        def apply[X](r: ReaderPort[X]) = Reader((c: Conf) => r.run(c.port))      }      val action: Eff[SS, String] = for {        s1 <- readHost.transform(fromHost)        s2 <- readPort.transform(fromPort)      } yield s1 + \" \" + s2      action.runReader(Conf(\"www.me.com\", 8080)).runOption.run`> Some(hello world)`There are also specialized versions of `transform` for `Reader` and `State`: - `ReaderEffect.localReader` takes a \"getter\" `B => A` to transform a stack with a `Reader[A, *]` into a stack with a `Reader[B, *]` - `StateEffect.lensState` takes a \"getter\" `S => T` and a \"setter\" `(S, T) => S` to to transform a stack with a `State[T, *]` into a stack with a `State[S, *]` Translate an effect into multiple othersA common thing to do is to translate effects (a webservice DSL for example) into multiple others (`TimedFuture`, `Eval`, `Either`, etc...).For example you might have this stack:type S = Fx.fx3[Authenticated, TimedFuture, Either[AuthError, *]]And you want to write an interpreter which will translate authentication actions into `TimedFuture` and `Either`:import org.atnos.eff._      import org.atnos.eff.syntax.eff._      import org.atnos.eff.future._      import org.atnos.eff.interpret._      import scala.concurrent.Future// list of access rights for a valid token      case class AccessRights(rights: List[String])// authentication error      case class AuthError(message: String)// DSL for authenticating users      sealed trait Authenticated[A]      case class Authenticate(token: String) extends Authenticated[AccessRights]      type _authenticate[U] = Authenticated |= U      type AuthErroEither[A] = AuthError Either A      type _error[U] = AuthErroEither |= U      /** * The order of implicit parameters is really important for type inference! * see below */      def runAuth[R, U, A](e: Eff[R, A])(implicit authenticated: Member.Aux[Authenticated, R, U], future: _future[U], either: _error[U]): Eff[U, A] =        translate(e)(new Translate[Authenticated, U] {          def apply[X](ax: Authenticated[X]): Eff[U, X] =            ax match {              case Authenticate(token) =>                // send the TimedFuture effect in the stack U                fromFuture(authenticateImpl(token)).                  // send the Either value in the stack U                collapse            }        })// call to a service to authenticate tokens      def authenticateImpl(token: String): Future[AuthError Either AccessRights] =        Future.successful[AuthError Either AccessRights] { Left(AuthError(\"token invalid!\")) }      def authenticate[S: _authenticate](token: String) = Authenticate(token).send      type S1 = Fx.fx3[Authenticated, Either[AuthError, *], TimedFuture]      type R1 = Fx.fx2[Either[AuthError, *], TimedFuture]      val result: Eff[R1, AccessRights] = runAuth(authenticate[S1](\"faketoken\"))The call to `send` above needs to send an `TimedFuture` value in the stack `U`. This is possible because `TimedFuture` is aneffect in `U` as evidenced by `future`.Furthermore, `authenticate` returns an `Either[AuthError, *]` value. We can \"collapse\" it into `U` because `Either[AuthError, *]`is an effect of `U` as evidenced by `either`.You might wonder why we don't use a more direct type signature like:def runAuth2[R, U :_future :_error, A](e: Eff[R, A])(  implicit authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A]The reason is that scalac desugars this to:def runAuth2[R, U, A](e: Eff[R, A])(  implicit future:        _future[U],           either:        _error[U],           authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A] =And then `authenticated` is last in the list of implicits parameters and can not be used to guide type inference. Interpret an effect \"locally\"Let's say you have a method to run database queriesimport org.atnos.eff._      import org.atnos.eff.all._      import cats.data._      trait Db[A]      type _writerString[R] = Writer[String, *] |= R      def runDb[R, U, A](queries: Eff[R, A])(implicit db: Member.Aux[Db, R, U], eval: _eval[U], writer: _writerString[U]): Eff[U, A] = ???The database queries (the `Db` effect) are being executed by the `runDb` method inside the `Eval` effect, and they use a `WriterString` effect to log what is being executed.However you know that some clients of your component don't care about the logs and they don't want to have the `WriterString` effect. that they consider an implementation detail.So you'd like to provide this additional method:      def executeOnDb[R, U, A](queries: Eff[R, A])(implicit db: Member.Aux[Db, R, U], eval: _eval[U]): Eff[U, A] = ???How can you implement `executeOnDb` with `runDb`?      import org.atnos.eff.all._      import org.atnos.eff.syntax.all._      def executeOnDb[R, U, A](queries: Eff[R, A])(implicit db: Member.Aux[Db, R, U], eval: _eval[U]): Eff[U, A] = {        type S = Fx.prepend[WriterString, R]        runDb(queries.into[S]).runWriterNoLog[String]      }You create a \"local\" stack containing the `WriterString` effect using the `prepend` method. You now run the `Db` effect anddiscard the logs to finally return only `Eff[U, A]`. Merge stacksWe can create effects for a given effect stack, for example to interact with a [Hadoop](https://hadoop.apache.org) cluster.We can also define another stack, for storing and retrieving data on [S3](https://aws.amazon.com/s3).    import org.atnos.eff._  import all._  import cats.data._  import cats.Eval  object HadoopStack {    case class HadoopConf(mappers: Int)    type HadoopReader[A] = Reader[HadoopConf, A]    type WriterString[A] = Writer[String, A]    type Hadoop = Fx.fx3[HadoopReader, WriterString, Eval]    def readFile(path: String): Eff[Hadoop, String] =      for {        c <- ask[Hadoop, HadoopConf]        _ <- tell[Hadoop, String](\"Reading from \" + path)      } yield c.mappers.toString    def runHadoopReader[R, U, A](conf: HadoopConf)(e: Eff[R, A])(implicit r: Member.Aux[HadoopReader, R, U]): Eff[U, A] =      ReaderEffect.runReader(conf)(e)  }  object S3Stack {    case class S3Conf(bucket: String)    type S3Reader[A] = Reader[S3Conf, A]    type WriterString[A] = Writer[String, A]    type S3 = Fx.fx3[S3Reader, WriterString, Eval]    def writeFile(key: String, content: String): Eff[S3, Unit] =      for {        c <- ask[S3, S3Conf]        _ <- tell[S3, String](\"Writing to bucket \" + c.bucket + \": \" + content)      } yield ()    def runS3Reader[R, U, A](conf: S3Conf)(e: Eff[R, A])(implicit r: Member.Aux[S3Reader, R, U]): Eff[U, A] =      ReaderEffect.runReader(conf)(e)  }So what happens when you want to both use S3 and Hadoop? As you can see from the definition above those 2 stacks sharesome common effects, so the resulting stack we want to work with is:import org.atnos.eff._      import cats.Eval      import HadoopStack._      import S3Stack.{WriterString => _, _}      type HadoopS3 = Fx.fx4[S3Reader, HadoopReader, WriterString, Eval]Then we can use the `into` method to inject effects from each stack into this common stack:      import S3Stack._      import HadoopStack._// this imports the `into` and runXXX syntax      import org.atnos.eff.syntax.all._      val action = for {        // read a file from hadoop        s <- readFile(\"/tmp/data\").into[HadoopS3]        // write a file on S3        _ <- writeFile(\"key\", s).into[HadoopS3]      } yield ()      // and we can run the composite action      action.runReader(S3Conf(\"bucket\")).runReader(HadoopConf(10)).runWriter.runEval.run`> ((),List(Reading from /tmp/data, Writing to bucket bucket: 10))`You can find a fully working example of this approach in `src/test/org/atnos/example/StacksSpec`.", "tags":"", "loc":"org.atnos.site.TransformStack.html"},
{"title":"Member implicits", "text":"Type inference with the Eff monad can be a bit tricky to get right if we want to avoid type annotations. Here are sometips to help you. Running effects with several type parametersSome effects use 2 type variables, like `Reader` or `Writer`. If you want to use those effects in an effect stack you needto make sure you have the following `scalac` option:scalascalacOptions += \"-Ypartial-unification\" Use context bounds and type aliasesWhen creating effects you can always \"require\" a stack containing the right effects with the `MemberIn` typeclass:import org.atnos.eff._      import org.atnos.eff.all._      type StateInt[A] = State[Int, A]      type WriterString[A] = Writer[String, A]// for creating state effects      def putAndTell[R](i: Int)(implicit s: StateInt |= R, w: WriterString |= R): Eff[R, Int] =        for {          // no type annotations needed!          _ <- put(i)          _ <- tell(\"stored \" + i)        } yield iYou can even use context bounds to make the declaration of `putAndTell` more concise:import org.atnos.eff.all._      type _stateInt[R] = State[Int, *] |= R      type _writerString[R] = Writer[String, *] |= R      def putAndTell[R: _stateInt: _writerString](i: Int): Eff[R, Int] =        for {          _ <- put(i)          _ <- tell(\"stored \" + i)        } yield i Know your `Member` typeclassesThere are 3 different ways to declare that an effect is part of an effect stack with 3 typeclasses: Typeclass             | Alias    | Meaning                                            | When to use it -----------           | -----    | --------------------                               | -------------------------------- `MemberIn[M, R]`      | `M |= R` | \"`M` is part of `R`\"                               | to create `M` effects in `R` `MemberInOut[M, R]`   | `M /= R` | \"`M` is part of `R` and can be extracted from it\"  | to intercept the effect `M` (see `Interpreter.scala`) and transform it while staying in the same stack. For example to `handleError` for an Error effect `Member[M, R]`        | `M <= R` | \"`M` is part of `R`, can be extracted from it, and the resulting stack is `m.Out`\" | to interpret the effect in terms of special values or other effects and remove the effect from the stack \"Packing\" member instancesSome function signatures can be repetitive when they always require the same list of effects:scaladef foo1[R :_foo :_bar :_baz](i: Int): Eff[R, Int]def foo2[R :_foo :_bar :_baz](i: Int): Eff[R, Int]def foo3[R :_foo :_bar :_baz](i: Int): Eff[R, Int]It is possible to \"pack\" them with the following `_effects` type definition:import org.atnos.eff.Members.{&:, &&:}      trait Foo[A]      trait Bar[A]      trait Baz[A]      trait Boo[A]      type _foo[R] = Foo |= R      type _bar[R] = Bar |= R      type _baz[R] = Baz |= R// Note the last &&:, you can write instead: _foo[R] &: _bar[R] &: _baz[R] &: NoMember      type _effects[R] = _foo[R] &: _bar[R] &&: _baz[R]      def getFoo[R: _foo: _bar]: Eff[R, Int] = Eff.pure(1)      def getBar[R: _bar]: Eff[R, Int] = Eff.pure(1)      def getBaz[R: _baz]: Eff[R, Int] = Eff.pure(1)      object t {        import org.atnos.eff.Members.extractMember        def foo[R: _effects](i: Int): Eff[R, Int] =          getFoo[R] >>            getBar[R] >>            getBaz[R]      }// Then call foo with a concrete stack      type S = Fx.fx3[Foo, Bar, Baz]      type U = Fx.fx4[Foo, Bar, Baz, Boo]      t.foo[S](1)      t.foo[U](1)The implicit definition `extractMember` in the `Members` object will take care of \"unpacking\" the member instances where required.Note that this implicit must *not* be in scope when calling the methods requiring the \"packed\" implicits otherwise it willtrigger a divergent implicit search.", "tags":"", "loc":"org.atnos.site.MemberImplicits.html"},
{"title":"Applicative", "text":" Concurrent evaluationThe default interpretation of `Eff` values is \"monadic\" meaning that effectful values are being evaluated in order. This  becomes clear when traversing a list of values with the `FutureEffect`:import org.atnos.eff._, all._, future._, syntax.all._      import cats.Eval      import cats.data.Writer      import cats.syntax.traverse._      import cats.instances.list._      import scala.concurrent._, duration._, ExecutionContext.Implicits.global      import org.atnos.eff.concurrent.Scheduler      import org.atnos.eff.syntax.future._      type WriterString[A] = Writer[String, A]      type _writerString[R] = WriterString |= R      type S = Fx.fx3[Eval, TimedFuture, WriterString]      implicit val scheduler: Scheduler = ExecutorServices.schedulerFromGlobalExecutionContext      def execute[E: _eval: _writerString: _future](i: Int): Eff[E, Int] =        for {          i1 <- delay(i)          i2 <- futureDelay(i1)          _ <- tell(i2.toString)        } yield i2      val action: Eff[S, List[Int]] =        List(1000, 500, 50).traverse(execute[S])      Await.result(action.runEval.runWriterLog.runSequential, 2.seconds)`> List(1000, 500, 50)`We can however run all those computations concurrently using the applicative execution for `Eff`:      val action: Eff[S, List[Int]] =        List(1000, 500, 50).traverseA(execute[S])      Await.result(        Eff.detachA(action.runEval.runWriterLog[String])(TimedFuture.MonadTimedFuture, TimedFuture.ApplicativeTimedFuture).runNow(scheduler, global),        2.seconds      )`> List(1000, 500, 50)`This uses now `traverseA` (instead of `traverse`) to do an applicative traversal and execute futures concurrently andthe fastest actions finish first. BatchingAnother advantage of applicative effects is that we can intercept them individual requests and \"batch\" them into one singlerequest. For example: import org.atnos.eff._, all._, syntax.all._      import cats.syntax.all._// An effect to get users from a database// calls can be individual or batched      case class User(i: Int)      sealed trait UserDsl[+A]      case class GetUser(i: Int) extends UserDsl[User]      case class GetUsers(is: List[Int]) extends UserDsl[List[User]]      type _userDsl[R] = UserDsl /= R      def getUser[R: _userDsl](i: Int): Eff[R, User] =        send[UserDsl, R, User](GetUser(i))Let's create an interpreter for this DSL:// the real method calls to a webservice      def getWebUser(i: Int): User = User(i)      def getWebUsers(is: List[Int]): List[User] = is.map(i => User(i))// the interpreter simply calls the webservice// and return a trace of the executed call      def runDsl[A](eff: Eff[Fx1[UserDsl], A]): (A, Vector[String]) = {        @tailrec        def go(e: Eff[Fx1[UserDsl], A], trace: Vector[String]): (A, Vector[String]) =          e match {            case Pure(a, _) => (a, trace)            case Impure(UnionTagged(GetUser(i), _), c, _) => go(c(getWebUser(i)), trace :+ \"getWebUser\")            case Impure(UnionTagged(GetUsers(is), _), c, _) => go(c(getWebUsers(is)), trace :+ \"getWebUsers\")            case ap @ ImpureAp(_, _, _) => go(ap.toMonadic, trace)            case Impure(_, _, _) => sys.error(\"this should not happen with just one effect\")          }        go(eff, Vector())      }We can also optimise a `UserDsl` program by providing a `Batchable` instance describing how to \"batch\"2 calls into 1:      implicit def BatchableUserDsl: Batchable[UserDsl] = new Batchable[UserDsl] {        type Z = List[User]        type E = User        def distribute(z: List[User]) = z        def batch[X, Y](tx: UserDsl[X], ty: UserDsl[Y]): Option[UserDsl[Z]] = Option {          (tx, ty) match {            case (GetUser(i), GetUser(j)) => GetUsers(List(i, j))            case (GetUser(i), GetUsers(is)) => GetUsers(i :: is)            case (GetUsers(is), GetUser(i)) => GetUsers(is :+ i)            case (GetUsers(is), GetUsers(js)) => GetUsers(is ++ js)          }        }      }Now let's create a program using the `User` DSL with applicative calls which can be optimised:      def program[R: _userDsl]: Eff[R, List[User]] =        Eff.traverseA(List(1, 2, 3))(i => getUser(i))And its optimised version:      def optimised[R: _userDsl]: Eff[R, List[User]] =        program.batchRunning the optimised and non-optimised version of the program must yield the same results:      show(runDsl(program[Fx1[UserDsl]]), runDsl(optimised[Fx1[UserDsl]]))original:  User(1), User(2), User(3)  trace: getWebUser, getWebUser, getWebUseroptimised: User(1), User(2), User(3)  trace: getWebUsers", "tags":"", "loc":"org.atnos.site.ApplicativeEvaluation.html"},
{"title":"Cookbook", "text":"A collection of examples of how to solve particular problems with Eff Partial InterpretationIt's common to want to use different effects in different parts of a program. Some effects, like error handling orlogging, may extend through the whole of our program. However we may want to include additional effects,like state, within one part.The example below shows how we can do this - the `incrementNTimes` methods uses an additional `State` effect for its implementation (necessary to call `incrementCounter`) - the additional `State` effect is added to `R` with the `prepend` method: `Fx.prepend[StateInt, R]` - `runState` is called within `incrementNTimes` to finally interpret that effectimport cats._, data._      import cats.syntax.all._      import org.atnos.eff._      import org.atnos.eff.all._      import org.atnos.eff.syntax.all._// Some type definitions for the effects we will use      type EitherString[A] = Either[String, A]      type WriterString[A] = Writer[String, A]      type StateInt[A] = State[Int, A]      type _err[R] = EitherString |= R      type _log[R] = WriterString |= R      type _count[R] = StateInt |= R      /** * In module 1, some utility methods */// repeat a side-effect n times      def repeatM[M[_]: Monad](n: Int, computation: M[Unit]): M[Unit] =        if (n <= 0) computation        else computation >> repeatM(n - 1, computation)// check a condition and abort computations with a message if the condition is false      def assert[R: _err](condition: Boolean, msg: String): Eff[R, Unit] =        if (!condition) left(msg) else right(())// increment a counter and log the new value      def incrementCounter[R: _log: _count]: Eff[R, Unit] = for {        c <- get        c2 = c + 1        _ <- tell(s\"counter == $c2\")        _ <- put(c2)      } yield ()      /** * In module 2 your \"business\" logic */// increment a value n times (n need to be positive)      def incrementNTimes[R: _err: _log](start: Int, times: Int): Eff[R, Int] = for {        // this call uses the stack R        _ <- assert(times >= 0, s\"$times is negative\")        // the call uses the stack R plus an additional StateInt effect which is interpreted right away.        // The other effects remain        result <- repeatM(times, incrementCounter[Fx.prepend[StateInt, R]]).execState(start)      } yield result      /** * A top-level call */      type Stack = Fx.fx2[EitherString, WriterString]      incrementNTimes[Stack](3, 2).runWriter.runEither.run`> Right((6,List(counter == 4, counter == 5, counter == 6)))`", "tags":"", "loc":"org.atnos.site.Cookbook.html"},
{"title":"Community resources", "text":"A collection of resources related to Eff. Blog posts- [A Journey into Extensible Effects in Scala](https://rea.tech/a-journey-into-extensible-effects-in-scala/) Tutorials & Examples- [Getting work done with Effectful Functional Programming](https://github.com/benhutchison/GettingWorkDoneWithExtensibleEffects)", "tags":"", "loc":"org.atnos.site.CommunityResources.html"},
{"title":"eff", "text":"Extensible effects are an alternative to monad transformers for computing with effects in a functional way.This library is based on the \"free-er\" monad and an \"open union\" of effects described byOleg Kiselyov in [Freer monads, more extensible effects](https://okmij.org/ftp/Haskell/extensible/more.pdf).You can learn more in the following sections, it is recommended to read them in order if you are new to `eff`: 1.  1.  1. : `Reader`, `Writer`, `Eval`, `State`,... 1.  1.  1.  1.  1.  1.  1.  Contributing`eff` is a [Typelevel](https://typelevel.org) project. This means we embrace pure, typeful, functional programming,and provide a safe and friendly environment for teaching, learning, and contributing as described in the [Scala Code of Conduct](https://www.scala-lang.org/conduct/).Feel free to open an issue if you notice a bug, have an idea for a feature, or have a question about the code. Pull requests are also gladly accepted.", "tags":"", "loc":"index.html"}]};
     