
var tipuesearch = {"pages": [{"title":"Eval", "text":"This effect is a very simple one. It allows the delayed execution of computations and it can serve as some sort of overall `IO` effect.Two methods are available to execute this effect: - `runEval: Eff[U, A]` to just execute the computations - `attemptEval: Eff[U, Throwable Either A]` to execute the computations but also catch any `Throwable` that would be thrown> 2`", "tags":"", "loc":"org.atnos.site.lib.EvalEffectPage.html"},
{"title":"Option", "text":"Adding an `Option` effect in your stack allows to stop computations when necessary.If you create a value with `some(a)` this value will be used downstream but if you use `none` all computations will stop:> (Some(30),None)`", "tags":"", "loc":"org.atnos.site.lib.OptionEffectPage.html"},
{"title":"Either", "text":"The `Either` effect is similar to the `Option` effect but adds the possibility to specify why a computation stopped: > (Right(30),Left('missing' not found))`*Note*: the `*` syntax comes from the [kind-projector](https://github.com/typelevel/kind-projector) project and allows us to avoidtype lambdas.A `catchLeft` method can also be used to intercept an error and possibly recover from it:``*Note*: the type annotations on `left` and `right` can be avoided by adding an implicit declaration in scope. You can learnmore about this in the  section.", "tags":"", "loc":"org.atnos.site.lib.EitherEffectPage.html"},
{"title":"Validate", "text":"The `Validate` effect is similar to the `Either` effect but let you accumulate failures: > Left(NonEmptyList(-3 is not positive, -2 is not positive))`", "tags":"", "loc":"org.atnos.site.lib.ValidateEffectPage.html"},
{"title":"Error", "text":"The `Error` effect is both an `Eval` effect and a `Either` one with `Throwable Either F` on the \"left\" side.  The idea is to represent computations which can fail, either with an exception or a failure. You can:  - create delayed computations with `ok`- fail with `fail(f: F)` where `F` is the failure type- throw an exception with `exception`Other useful combinators are available:  - `andFinally(last)` registers an action to be executed even in case of an exception or a failure- `orElse` runs an action and then run another one if the first is not successful- `whenFailed` does the same thing than `orElse` but uses the error for `action1` to decide which action to run nextWhen you run an `Error` effect you get back an `Error Either A` where `Error` is a type alias for `Throwable Either Failure`.  The `Error` object implements this effect with `String` as the `Failure` type but you are encouraged to create our own  failure datatype and extend the `Error[MyFailureDatatype]` trait.", "tags":"", "loc":"org.atnos.site.lib.ErrorEffectPage.html"},
{"title":"Reader", "text":"The `Reader` effect is used to request values from an \"environment\". The main method is `ask` to get the current environment(or \"configuration\" if you prefer to see it that way) and you can run an effect stack containing a `Reader` effect byproviding a value for the environment with the `runReader` method.You can also inject a \"local\" reader into a \"bigger\" one:> the port is 80`", "tags":"", "loc":"org.atnos.site.lib.ReaderEffectPage.html"},
{"title":"Writer", "text":"You can then define your own custom `Fold` to log the values to a file:> List(second value 2, first value 1)`", "tags":"", "loc":"org.atnos.site.lib.WriterEffectPage.html"},
{"title":"State", "text":"A `State` effect can be seen as the combination of both a `Reader` and a `Writer` with these operations: - `get` get the current state - `put` set a new stateLet's see an example showing that we can also use tags to track different states at the same time:> initial: (10,hello), final: (5,10)`In the example above we have used an `eval` method to get the `A` in `Eff[R, A]` but it is also possible to get both the value and the state with `run` or only the state with `exec`.Instead of tagging state effects it is also possible to transform a State effect acting on a \"small\" state into a Stateeffect acting on a \"bigger\" state:``> (there are 3 valuesthe sum is 6,(3,6))", "tags":"", "loc":"org.atnos.site.lib.StateEffectPage.html"},
{"title":"List", "text":"The `List` effect is used for computations which may return several values.A simple example using this effect would be > List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))`", "tags":"", "loc":"org.atnos.site.lib.ListEffectPage.html"},
{"title":"Choose", "text":"The `Choose` effect is used for non-deterministic computations. With the `Choose` effect you can model computations which either:  - return no result at all  - choose between 2 different computations`Choose` is actually a generalization of `List` where instead of \"exploring\" all the branches we might \"cut\" some of them.That behaviour is controlled by the `Alternative[F]` instance you use when running `Choose`.For example if we take `List` to run a similar example as before, we get the list of all the accepted pairs: > List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))`", "tags":"", "loc":"org.atnos.site.lib.ChooseEffectPage.html"},
{"title":"Memo", "text":"The Memo effect allows the caching of expensive computations. Computations are \"stored\" with a given key, so that the nextcomputation with the same key will return the previously computed value. When interpreting those computations a `Cache` mustbe provided: > there is only one invocation <=> true`There are 2 cache implementations provided in this library to support the Memo effect: - `org.atnos.eff.ConcurrentHashMapCache`: backed by a `java.util.concurrent.ConcurrentHashMap` where the keys are hashcodes for the keys used to memoize the values. This cache is thread-safe but unbounded so use with care! - `org.atnos.eff.ConcurrentWeakIdentityHashMapCache`: backed by a `ConcurrentWeakIdentityHashMap` where the keys are `System.identityHashCode`   for the keys used to memoize the values. This cache is thread-safe and uses weak references which can be garbage collected when   necessary.You can also use other, and better, cache implementations like [Caffeine](https://github.com/ben-manes/caffeine) to get more functionalitieslike eviction policies, maximum size and so on. You will need to implement the `Cache` interface for thisscalatrait Cache {  def memo[V](key: AnyRef, value: =>V): V}", "tags":"", "loc":"org.atnos.site.lib.MemoEffectPage.html"},
{"title":"TimedFuture", "text":"The `TimedFuture` effect is a thin shim on top of Scala's `Future`. The only extra capability it has built-in istimeouts, which are supported by passing in a `ScheduledExecutionContext`.Note that because `Future` represents a computation already taking place, `TimedFuture` is a function that returns a `Future`.This means if you start a computation before passing the `Future` into Eff, the `Future` will begin less predictably.Now, let's create some `TimedFuture` effects:> Some(1)`You can also use other `Future` or `Task` effects: - `monix`: depend on `eff-monix` and import `org.atnos.eff.addon.monix.task._`There are corresponding syntax imports to be able to call `runAsync` methods in: - `monix`: `org.atnos.eff.syntax.addon.monix.task._``Future` and `Task` computations can also be memoized to avoid expensive computations to be done several times. You can either - use the `futureMemo/taskMemo` operator with a (mutable) cache - use the `futureMemoized/taskMemoized` operator with the `Memoized` effect (you will need to provide the cache later)<p/>> there is only one invocation <=> true`", "tags":"", "loc":"org.atnos.site.lib.TimedFutureEffectPage.html"},
{"title":"Task", "text":"The `Task` effect is a thin shim on top of Monix's `Task`. This effect is not bundled in core Eff and requiresthe `eff-monix` extension to use.Now, let's create some `Task` effects:> Some(1)`", "tags":"", "loc":"org.atnos.site.lib.TaskEffectPage.html"},
{"title":"Safe", "text":"The Safe effect is useful to handle resources which must be closed even in the presence of exceptions. The mainoperations are - `finally` to create an action which must always be executed after another one, even if the first one fails - `catchThrowable` to handle a thrown exception - `bracket(open)(step)(close)` to open a resource, use it and then close it safely. The `close` part is a \"finalizer\"<p/>Let's see an example for the protection of a resource: ``> ResultsWithout exception: Right(55), finalizers exceptions: no exceptions,	resource is closed: trueWith exception   : Left(boo), finalizers exceptions: no exceptions,	resource is closed: trueAs you can see in the signature of `program` the return value of `runSafe` is `(Throwable Either A, List[Throwable])`.The first part is the result of your program, which may end with an exception, and the second part is the list ofpossible exceptions thrown by the finalizers which can themselves fail.A simpler version of `bracket` is `finally`.This example show how to use `finally` but also what happens if a finalizer fails:``> ResultsComputation ok, finalizer ok: Right(55), finalizers exceptions: no exceptionsComputation ok, finalizer ko: Right(55), finalizers exceptions: List(failed!!)Computation ko, finalizer ok: Left(boo), finalizers exceptions: no exceptionsComputation ko, finalizer ko: Left(boo), finalizers exceptions: List(failed!!)Finally (no pun intended!) note that you can use `execSafe` if you are not interested in the result of the finalizers.", "tags":"", "loc":"org.atnos.site.lib.SafeEffectPage.html"},
{"title":"Installation", "text":"You add `eff` as an sbt dependency:scalalibraryDependencies += \"org.atnos\" %% \"eff\" % \"8.0.0\"// to write types like Reader[String, *]// for Scala 3.3.xscalacOptions += \"-Ykind-projector\"// for latest Scala 3scalacOptions += \"-Xkind-projector\" Additional dependenciesThis table lists the other available eff modules: Name              | Functionality ----------------- | ---------------------------------------------------- `eff-scalaz`      | if you want to use [Scalaz](https://github.com/scalaz/scalaz) as a library for functional programming. This gives you a `Scalaz` `Monad` instance for `Eff` and a Scalaz's `\/` effect `eff-monix`       | to use Monix's `Task` effect `eff-cats-effect` | to use cats's `IO` effect `eff-doobie`      | to use Doobie's `ConnectionIO` effect<p/> Imports Main typesThe main `eff` types: `Eff`, `Member`, `Fx` are accessible in the `org.atnos.eff` package:scalaimport org.atnos.eff._Many other effects are also available . Creating effectsThe functions used to create effects are grouped under different objects named after the effect type. For example if you want to create the `Eval` effect you need toimport:scalaimport org.atnos.eff.eval._You can also import most of the effects at once with:scalaimport org.atnos.eff.all._The only effects not included in the previous import are: - the `Error` effect. This effect requires a type parameter representing the \"failure\" type and must be provided by the user of the library - the `Future` effect. This effect shares some operations like `runAsync` with other \"async\" effects like monix's `TaskEffect`    and the import could clash with `import org.atnos.eff.addon.monix.task._` Interpreting effectsInterpreting effects usually requires some syntax to \"run\" a given effect. For example to \"run\" the `Option` effect you will import:scala// to create the effectimport org.atnos.eff.option._// to access the runOption methodimport org.atnos.eff.syntax.option._fromOption(Option(1)).runOptionYou can also access all the syntax imports at once with:scalaimport org.atnos.eff.syntax.all.given Intellij supportIntellij error highlighting doesn't support implicit-directed type inference yet, check https://youtrack.jetbrains.com/issue/SCL-11140 or https://youtrack.jetbrains.com/issue/SCL-10753 for progress. With ScalazIf you use Scalaz as your functional programming library you might need additional imports in order to use some creationmethods specific to Scalaz. For example:scalaimport org.atnos.eff.addon.scalaz.either._fromDisjunction(\/-(1))There is also an `all` object importing all those methods at once:scalaimport org.atnos.eff.addon.scalaz.all._fromDisjunction(\/-(1))And you can already guess, there are some syntax imports following the same pattern:scalaimport org.atnos.eff.addon.scalaz.either._import org.atnos.eff.addon.scalaz.syntax.either._fromDisjunction(\/-(1)).runDisjunction", "tags":"", "loc":"org.atnos.site.Installation.html"},
{"title":"Introduction", "text":"Extensible effects are an alternative to monad transformers for computing with effects in a functional way.This library uses a \"free-er\" monad and extensible effects to create an \"effect stack\" as described in[Oleg Kiselyov's paper](https://okmij.org/ftp/Haskell/extensible/more.pdf).There are lots of advantages to this approach: - operations can be declared as \"requiring\" an effect, without the need to fix the full stack of effects in advance - effects handlers are modular and can be replaced with other implementations as needed (even at runtime) - the underlying implementation is performant and stack-safe - existing monadic datatypes can be integrated to the library - effect stacks can be modified or combinedThis is probably very abstract so let's see more precisely what this all means. First example*Please make sure you have done all the setup described on the  page first*A monadic action is modelled as a value of type `Eff[R, A]` where `R` denotes a set of effects and `A` is the valuereturned by the computation, possibly triggering some effects when evaluated.The effects `R` are modelled by a type-level list of \"effect constructors\", for example:``The stack `Stack` above declares 3 effects: - a `ReaderInt` effect to access some configuration number of type `Int` - a `WriterString` effect to log string messages - an `Eval` effect to only compute values on demand (a bit like lazy values)Now we can write a program with those 3 effects, using the primitive operations provided by `ReaderEffect`, `WriterEffect` and `EvalEffect`:> (64,List(the required power is 6, the result is 64))`As you can see, all the effects of the `Stack` type are being executed one by one: 1. the `Reader` effect, which provides a value, `6`, to each computation needing it 2. the `Writer` effect, which logs messages 3. the `Eval` effect to compute the \"power of 2 computation\" 4. `run` extracts the final result<br/>Maybe you noticed that the effects are not being executed in the same order as their order in the stack declaration.The effects can indeed be executed in any order. This doesn't mean though that the results will be the same. For examplerunning the `Writer` effect then `Either` effect returns `String Either (A, List[String])` whereas running the `Either` effect then the `Writer` effect returns `(String Either A, List[String])`.This all works thanks to some implicits definitions guiding Scala type inference towards theright return types. You can learn more on implicits in the  section.You can now get a more detailed presentation of the use of the Eff monad by reading the  oryou can learn about  supported by this library.", "tags":"", "loc":"org.atnos.site.Introduction.html"},
{"title":"Out of the box", "text":"This library comes with the following effects: Name                | Description                                                                      | Link ---------           | -------------------------------------------                                      | ----- `EvalEffect`        | an effect for delayed computations                                               |  `OptionEffect`      | an effect for optional computations, stopping when there's no available value    |  `EitherEffect`      | an effect for computations with failures, stopping when there is a failure       |  `ValidateEffect`    | an effect for computations with failures, allowing to collect failures           |  `ErrorEffect`       | a mix of Eval and Either, catching exceptions and returning them as failures     |  `ReaderEffect`      | an effect for depending on a configuration or an environment                     |  `WriterEffect`      | an effect to log messages                                                        |  `StateEffect`       | an effect to pass state around                                                   |  `ListEffect`        | an effect for computations returning several values                              |  `ChooseEffect`      | an effect for modeling non-determinism                                           |  `MemoEffect`        | an effect for memoizing values                                                   |  `FutureEffect`      | an effect for asynchronous computations                                          |  `TaskEffect`        | an effect for asynchronous computations using Monix Tasks                        |  `SafeEffect`        | an effect for guaranteeing resource safety                                       | <small>(from `org.atnos.eff._`)</small>Other modules listed in  provide additional effects (Scalaz Task, Doobie ConnectionIO,...).<br/> What's next?Now you can learn how to  !", "tags":"", "loc":"org.atnos.site.OutOfTheBox.html"},
{"title":"Tutorial", "text":"This tutorial is intentionally structured like the [Free monad tutorial for cats](https://typelevel.org/cats/datatypes/freemonad.html) so that a side-by-side comparison of the 2 approaches is possible. Study your topicLet's imagine that we want to create a DSL for a key-value store. We want to be able to do three things with keys:  - put a value into the store, associated with its key.  - get a value from the store given its key.  - delete a value from the store given its key.<p/>The idea is to write a sequence of these operations in the embedded DSL as a \"program\",interpret the \"program\", and finally execute the \"program\" to interact with the actual key-value store.For example: put(\"toto\", 3) get(\"toto\") // returns 3 delete(\"toto\")But we want: - the computation to be represented as a pure, immutable value - to separate the creation and execution of the program - to be able to support many different methods of execution Create an ADT representing your grammarADT stands for \"Algebraic Data Type\". In this context, it refers to a closed set of types which can be combined tobuild up complex, recursive values.We need to create an ADT to represent our key-value operations: // the type parameter A can be read as the type of value returned by the operation  sealed trait KVStore[+A]  case class Put[T](key: String, value: T) extends KVStore[Unit]  case class Get[T](key: String) extends KVStore[Option[T]]  case class Delete(key: String) extends KVStore[Unit] Free your ADTThere are four basic steps to \"freeing\" the ADT: 1. Create smart constructors for `KVStore[_]` using `Eff.send` 1. Build a program out of key-value DSL operations 1. Build an interpreter for programs of DSL operations 1. Execute our interpreted program 1. [optional] add some syntax for the interpreter Create smart constructors using `Eff.send`These methods will let you create `Eff` values for your key-value store \"Effect\":  import org.atnos.eff._// T |= R is an alias for MemberIn[T, R]// stating that effects of type T[_] can be injected in the effect stack R// It is also equivalent to MemberIn[KVStore, R]  type _kvstore[R] = KVStore |= R  /** store returns nothing (i.e. Unit) */  def store[T, R: _kvstore](key: String, value: T): Eff[R, Unit] =    Eff.send[KVStore, R, Unit](Put(key, value))  /** find returns a T value if the key exists */  def find[T, R: _kvstore](key: String): Eff[R, Option[T]] =    Eff.send[KVStore, R, Option[T]](Get(key))  /** delete returns nothing (i.e. Unit) */  def delete[R: _kvstore](key: String): Eff[R, Unit] =    Eff.send(Delete(key))  /** update composes get and put, and returns nothing. */  def update[T, R: _kvstore](key: String, f: T => T): Eff[R, Unit] =    for {      ot <- find[T, R](key)      _ <- ot.map(t => store[T, R](key, f(t))).getOrElse(Eff.pure(()))    } yield ()Each method requires the `KVStore` effect to be a member of an \"effect stack\" `R`. The return values are of type `Eff[R, A]` where `R` is a stack of effects possibly containing other effects than key-value store operations and yielding values of type `A`. Build a programNow that we can construct values with `KVStore` effects we can use our DSL to write \"programs\" using a for-comprehension:   import org.atnos.eff._  def program[R: _kvstore]: Eff[R, Option[Int]] =    for {      _ <- store(\"wild-cats\", 2)      _ <- update[Int, R](\"wild-cats\", _ + 12)      _ <- store(\"tame-cats\", 5)      n <- find[Int, R](\"wild-cats\")      _ <- delete(\"tame-cats\")    } yield nThis looks like a monadic flow. However, it just builds a recursive data structure representing the sequence of operations. Write an interpreter for your programAs you may have understood now, `Eff` is used to create an embedded DSL. By itself, this DSL only represents a sequence of operations (defined by a recursive data structure); it doesn't produce anything.`Eff` is a programming language inside your programming language!So, like any other programming language, we need to interpret our abstract language into concrete values.To do this, we will use an interpreter transforming our `KVStore` effects using a simple mutable map:   import org.atnos.eff._  import interpret._  import cats.Traverse  import cats.syntax.all._  import scala.collection.mutable._  /** * Unsafe interpreter for KVStore effects * * the program will crash if a type is incorrectly specified. * * The interpreter requires the KVStore effect to be a Member of R (with <=) * Meaning that we can statically know the resulting type once we have removed * KVStore from R, and this type is m.Out. * * The interpreter uses the `interpretUnsafe` method from `org.atnos.eff.Interpreter` to implement a * stack-safe interpretation of effects as a side-effect. * * `interpretUnsafe` needs the definition of a side-effect where * we get each `KVStore[X]` effect, run side-effects and return a value `X`. * * The resulting effect stack is m.Out which is R without the KVStore effects * */  def runKVStoreUnsafe[R, A](effects: Eff[R, A])(using m: KVStore <= R): Eff[m.Out, A] = {    // a very simple (and imprecise) key-value store    val kvs = Map.empty[String, Any]    val sideEffect = new SideEffect[KVStore] {      def apply[X](kv: KVStore[X]): X =        kv match {          case Put(key, value) =>            println(s\"put($key, $value)\")            kvs.put(key, value)            ()          case Get(key) =>            println(s\"get($key)\")            kvs.get(key).asInstanceOf[X]          case Delete(key) =>            println(s\"delete($key)\")            kvs.remove(key)            ()        }      def applicative[X, Tr[_]: Traverse](ms: Tr[KVStore[X]]): Tr[X] =        ms.map(apply)    }    interpretUnsafe(effects)(sideEffect)(using m)  }Please note this interpreter is impure -- it mutates `kvs` and also produces logging output using `println`.The whole purpose of functional programming isn't to prevent side-effects, it is just to push side-effects to theboundaries of your system in a well-known and controlled way.We can also interpret `KVStore` effects differently and delegate the results to other effects in the same stack: - `State` for maintaining the map of values - `Writer` for logging - `Either[E, *]` for type errors<p/>  import org.atnos.eff._  import org.atnos.eff.either._  import org.atnos.eff.writer._  import org.atnos.eff.state._  import org.atnos.eff.interpret._  import cats.syntax.all._  import cats.data._  type _writerString[R] = Writer[String, *] |= R  type _stateMap[R] = State[Map[String, Any], *] |= R  /** * Safe interpreter for KVStore effects * * It uses the following effects: * *  - Writer to create log statements *  - State to update a key-value Map *  - Either to raise errors if the type of an object in the map is not of the expected type * *  The resulting effect stack is U which is R without the KVStore effects * *  Note that we just require the Throwable, Writer and State effects to *  be able to be created in the stack U * * This interpreter uses the org.atnos.eff.interpreter.translate method * translating one effect of the stack to other effects in the same stack * * * NOTE: * - It is really important for type inference that the effects for U are listed after those for R! * * Implicit member definitions will NOT be found with the following definition: * * def runKVStore[R, U :_throwableEither :_writerString :_stateMap, A](effects: Eff[R, A]) ( *   implicit m: Member.Aux[KVStore, R, U]): Eff[U, A] = { * */  def runKVStore[R, U, A](    effects: Eff[R, A]  )(using m: Member.Aux[KVStore, R, U], throwable: _throwableEither[U], writer: _writerString[U], state: _stateMap[U]): Eff[U, A] = {    translate(effects)(new Translate[KVStore, U] {      def apply[X](kv: KVStore[X]): Eff[U, X] =        kv match {          case Put(key, value) =>            for {              _ <- tell(s\"put($key, $value)\")              _ <- modify((map: Map[String, Any]) => map.updated(key, value))              r <- fromEither(Either.catchNonFatal(()))            } yield r          case Get(key) =>            for {              _ <- tell(s\"get($key)\")              m <- get[U, Map[String, Any]]              r <- fromEither(Either.catchNonFatal(m.get(key).asInstanceOf[X]))            } yield r          case Delete(key) =>            for {              _ <- tell(s\"delete($key)\")              _ <- modify((map: Map[String, Any]) => map - key)              r <- fromEither(Either.catchNonFatal(()))            } yield r        }    })  }`Eff` is just a recursive structure that can be seen as sequence of operations producing other operations, withpotentially other effects. In this way it is similar to folding a `List`. We often use folds (e.g. `foldRight`) to obtaina single value from a list; this recurses over the structure, combining its contents.The idea behind an `Eff` interpreter is exactly the same. We \"fold\" the recursive structure by: - consuming each operation - compiling the operation into a target language - computing next operation<p/>An important aspect of interpreters is stack-safety. An interpreter evaluates each step of a computation on the stackthen calls itself to evaluate the other steps. The `org.atnos.eff.interpreter` object provides various methods helping youwrite a stack-safe interpreter: - `interpretUnsafe` makes you define a `SideEffect` trait to return a value `X` from an effect `T[X]` - `translate` makes you define a `Translate` trait to \"translate\" your effect into other effects in the same stack - both are specialized version of `interpret1` which makes you define a `Recurse` trait to either return a value `X`   from an effect or produce another `Eff` computation Run your programThe final step is naturally running your program after interpreting it to another `Eff` value. We need to - specify a concrete stack of effects containing the effect we want to interpret `Fx.fx1[KVStore]` (just one effect in the stack) - call our interpreter to get a `Eff[NoFx, A]` value - call a final `run` to get an `A` value<p/>Like this: > Some(14)`With the safe interpreter, the process is the same and we need to - specify an effect stack definition with all the effects - call our \"safe\" interpreter - call interpreters for all the other effects, including the final `NoFx` effect with `run`<p/>Like that: ``> Right(Some(14))put(wild-cats, 2)get(wild-cats)put(wild-cats, 14)put(tame-cats, 5)get(wild-cats)delete(tame-cats) Add some syntaxIt is nice to be able to \"chain\" `run` methods with this additional piece of syntax: ``> Right(Some(14))put(wild-cats, 2)get(wild-cats)put(wild-cats, 14)put(tame-cats, 5)get(wild-cats)delete(tame-cats) Composing ADTs with the Eff monadReal world applications often time combine different algebras. The typelevel set of effects `R` in `Eff[R, A]`lets us compose different algebras in the context of `Eff`.Let's see a trivial example of unrelated ADT's getting composed that can form a more complex program. First you defineyour ADTs with smart constructors:  import org.atnos.eff._  import all._  sealed trait Interact[A]  case class Ask(prompt: String) extends Interact[String]  case class Tell(msg: String) extends Interact[Unit]  type _interact[R] = Interact |= R  def askUser[R: _interact](prompt: String): Eff[R, String] =    send(Ask(prompt))  def tellUser[R: _interact](message: String): Eff[R, Unit] =    send(Tell(message))  sealed trait DataOp[A]  type _dataOp[R] = DataOp |= R  case class AddCat(a: String) extends DataOp[Unit]  case class GetAllCats() extends DataOp[List[String]]  def addCat[R: _dataOp](a: String): Eff[R, Unit] =    send(AddCat(a))  def getAllCats[R: _dataOp]: Eff[R, List[String]] =    send(GetAllCats())Then you simply require your program to have `MemberIn` instances for those effects:  import org.atnos.eff._  def program[R: _interact: _dataOp]: Eff[R, Unit] =    for {      cat <- askUser(\"What's the kitty's name?\")      _ <- addCat(cat)      cats <- getAllCats      _ <- tellUser(\"Current cats: \" + cats.mkString(\", \"))    } yield ()Finally we write one interpreter per ADT:  import cats._  import cats.syntax.all._  import org.atnos.eff._  import interpret._  def readLine(): String =    \"snuggles\"  def runInteract[R, A](effect: Eff[R, A])(using m: Interact <= R): Eff[m.Out, A] =    recurse(effect)(new Recurser[Interact, m.Out, A, A] {      def onPure(a: A): A = a      def onEffect[X](i: Interact[X]): Either[X, Eff[m.Out, A]] = Left[X, Eff[m.Out, A]] {        i match {          case Ask(prompt) =>            println(prompt)            readLine()          case Tell(msg) =>            println(msg)        }      }      def onApplicative[X, T[_]: Traverse](ms: T[Interact[X]]): Either[T[X], Interact[T[X]]] =        Left(ms.map {          case Ask(prompt) => println(prompt); readLine()          case Tell(msg) => println(msg)        })    })(using m)  def runDataOp[R, A](effect: Eff[R, A])(using m: DataOp <= R): Eff[m.Out, A] = {    val memDataSet = new scala.collection.mutable.ListBuffer[String]    recurse(effect)(new Recurser[DataOp, m.Out, A, A] {      def onPure(a: A): A = a      def onEffect[X](i: DataOp[X]): Either[X, Eff[m.Out, A]] = Left[X, Eff[m.Out, A]] {        i match {          case AddCat(a) => memDataSet.append(a); ()          case GetAllCats() => memDataSet.toList        }      }      def onApplicative[X, T[_]: Traverse](ms: T[DataOp[X]]): Either[T[X], DataOp[T[X]]] =        Left(ms.map {          case AddCat(a) => memDataSet.append(a); ()          case GetAllCats() => memDataSet.toList        })    })(using m)  }Now if we run our program for a Stack combining both effects and type in \"snuggles\" when prompted, we see something like this:``What's the kitty's name?Current cats: snuggles", "tags":"", "loc":"org.atnos.site.Tutorial.html"},
{"title":"Creating effects", "text":" CreationNew effects can be added to the library pretty easily. Let's create an Effect for a new \"optional\" type.We need: - a base type. We use a `Maybe` data type with 2 cases `Just` and `Nothing` - a method to send values of type `A` into `Eff[R, A]` - an interpreter  import cats._  import implicits._  import org.atnos.eff._  import all._  import org.atnos.eff.interpret._  sealed trait Maybe[A]  case class Just[A](a: A) extends Maybe[A]  case class Nothing[A]() extends Maybe[A]  object MaybeEffect {    type _maybe[R] = Maybe |= R    def just[R: _maybe, A](a: A): Eff[R, A] =      send[Maybe, R, A](Just(a))    def nothing[R: _maybe, A]: Eff[R, A] =      send[Maybe, R, A](Nothing())    def runMaybe[R, U, A](effect: Eff[R, A])(using m: Member.Aux[Maybe, R, U]): Eff[U, Option[A]] =      recurse(effect)(new Recurser[Maybe, U, A, Option[A]] {        def onPure(a: A): Option[A] = Some(a)        def onEffect[X](m: Maybe[X]): Either[X, Eff[U, Option[A]]] =          m match {            case Just(x) => Left(x)            case Nothing() => Right(Eff.pure(None))          }        def onApplicative[X, T[_]: Traverse](ms: T[Maybe[X]]): Either[T[X], Maybe[T[X]]] =          Right(ms.sequence)      })    given Applicative[Maybe] = new Applicative[Maybe] {      def pure[A](a: A): Maybe[A] = Just(a)      def ap[A, B](ff: Maybe[A => B])(fa: Maybe[A]): Maybe[B] =        (fa, ff) match {          case (Just(a), Just(f)) => Just(f(a))          case _ => Nothing()        }    }  }In the code above: - the `just` and `nothing` methods use `Eff.send` to \"send\" values into a larger sum of effects `Eff[R, A]` - `runMaybe` runs the `Maybe` effect by using the `interpret.recurse` and a `Recurser` to translate `Maybe` values into `Option` values Compiler limitationWhen you create an effect you can define a sealed trait and case classes to represent different possibilities for that effect.For example for interacting with a database you might create: ``It is recommended to create the `Db` types **outside** of the `DatabaseEffect` trait. Indeed, during `Member` implicit resolution,depending on how you import the `Db` effect type (if it is inherited from an object or not) you could experience compilercrashes :-(. InterpreterInterpreting a given effect generally means knowing what to do with a value of type `M[X]` where `M` is the effect. Ifthe interpreter can \"execute\" the effect: produce logs (`Writer`), execute asynchronously (`Future`), check the value (`Either`),...then extract a value `X`, then we can call a continuation to get the next effect and interpret it as well.The `org.atnos.eff.interpret` object offers several support traits and functions to write interpreters. In this example weuse a `Recurser` which will be used to \"extract\" a value `X` from `Maybe[X]` or just give up with `Eff.pure(None)`The `runMaybe` method needs an implicit `Member.Aux[Maybe, R, U]`. This must be read in the following way: - `Maybe` must be member of the effect stack `R` and its removal from `R` should be the effect stack `U`<br/>Then we can use this effect in a computation:> Some(5)`----", "tags":"", "loc":"org.atnos.site.CreateEffects.html"},
{"title":"Transform stacks", "text":" What is an \"effect stack\"?There is an abuse of language here. The name \"stack\" comes from \"monad stack\" used when talking about monad transformers.With `Eff` though, effects are modelled differently, as a tree of effects.For example the type level representation of four effects `T1, T2, T3, T4` is represented as:Fx.fx4[T1, T2, T3, T4]// orFxAppend[  Fx1[T1],  Fx3[T2, T3, T4]]So every-time we manipulate effects at the type level we modify a tree of effects. For example, interpreting the effect `T3`would leave us with the tree:FxAppend[  Fx1[T1],  Fx2[T2, T4]]This code should prove it:``Unfortunately the compiler has some difficulties with it, so you can either get the member value by using the  implicit definitions \"manually\" or you can just summon the member instance without the `Aux` part:``More importantly the compiler is still able to track the right types resulting of the interpretation of a given effectso the following compiles ok:`` Transform an effect to another Change the effectA typical use case for this is to transform a stack having a `Reader[S, *]` effect to a stack having a `Reader[B, *]` effect where `S` is \"contained\" in `B` (meaning that there is a mapping from `B`, \"big\", to `S`, \"small\"). Here is an example:> Some(hello world)`There are also specialized versions of `transform` for `Reader` and `State`: - `ReaderEffect.localReader` takes a \"getter\" `B => A` to transform a stack with a `Reader[A, *]` into a stack with a `Reader[B, *]` - `StateEffect.lensState` takes a \"getter\" `S => T` and a \"setter\" `(S, T) => S` to to transform a stack with a `State[T, *]` into a stack with a `State[S, *]` Translate an effect into multiple othersA common thing to do is to translate effects (a webservice DSL for example) into multiple others (`TimedFuture`, `Eval`, `Either`, etc...).For example you might have this stack:type S = Fx.fx3[Authenticated, TimedFuture, Either[AuthError, *]]And you want to write an interpreter which will translate authentication actions into `TimedFuture` and `Either`:``The call to `send` above needs to send an `TimedFuture` value in the stack `U`. This is possible because `TimedFuture` is aneffect in `U` as evidenced by `future`.Furthermore, `authenticate` returns an `Either[AuthError, *]` value. We can \"collapse\" it into `U` because `Either[AuthError, *]`is an effect of `U` as evidenced by `either`.You might wonder why we don't use a more direct type signature like:def runAuth2[R, U :_future :_error, A](e: Eff[R, A])(  implicit authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A]The reason is that scalac desugars this to:def runAuth2[R, U, A](e: Eff[R, A])(  implicit future:        _future[U],           either:        _error[U],           authenticated: Member.Aux[Authenticated, R, U]): Eff[U, A] =And then `authenticated` is last in the list of implicits parameters and can not be used to guide type inference. Interpret an effect \"locally\"Let's say you have a method to run database queries``The database queries (the `Db` effect) are being executed by the `runDb` method inside the `Eval` effect, and they use a `WriterString` effect to log what is being executed.However you know that some clients of your component don't care about the logs and they don't want to have the `WriterString` effect. that they consider an implementation detail.So you'd like to provide this additional method:``How can you implement `executeOnDb` with `runDb`?``You create a \"local\" stack containing the `WriterString` effect using the `prepend` method. You now run the `Db` effect anddiscard the logs to finally return only `Eff[U, A]`. Merge stacksWe can create effects for a given effect stack, for example to interact with a [Hadoop](https://hadoop.apache.org) cluster.We can also define another stack, for storing and retrieving data on [S3](https://aws.amazon.com/s3).    import org.atnos.eff._  import all._  import cats.data._  import cats.Eval  object HadoopStack {    case class HadoopConf(mappers: Int)    type HadoopReader[A] = Reader[HadoopConf, A]    type WriterString[A] = Writer[String, A]    type Hadoop = Fx.fx3[HadoopReader, WriterString, Eval]    def readFile(path: String): Eff[Hadoop, String] =      for {        c <- ask[Hadoop, HadoopConf]        _ <- tell[Hadoop, String](\"Reading from \" + path)      } yield c.mappers.toString    def runHadoopReader[R, U, A](conf: HadoopConf)(e: Eff[R, A])(using Member.Aux[HadoopReader, R, U]): Eff[U, A] =      ReaderEffect.runReader(conf)(e)  }  object S3Stack {    case class S3Conf(bucket: String)    type S3Reader[A] = Reader[S3Conf, A]    type WriterString[A] = Writer[String, A]    type S3 = Fx.fx3[S3Reader, WriterString, Eval]    def writeFile(key: String, content: String): Eff[S3, Unit] =      for {        c <- ask[S3, S3Conf]        _ <- tell[S3, String](\"Writing to bucket \" + c.bucket + \": \" + content)      } yield ()    def runS3Reader[R, U, A](conf: S3Conf)(e: Eff[R, A])(using Member.Aux[S3Reader, R, U]): Eff[U, A] =      ReaderEffect.runReader(conf)(e)  }So what happens when you want to both use S3 and Hadoop? As you can see from the definition above those 2 stacks sharesome common effects, so the resulting stack we want to work with is:``Then we can use the `into` method to inject effects from each stack into this common stack:> ((),List(Reading from /tmp/data, Writing to bucket bucket: 10))`You can find a fully working example of this approach in `src/test/org/atnos/example/StacksSpec`.", "tags":"", "loc":"org.atnos.site.TransformStack.html"},
{"title":"Member implicits", "text":"Type inference with the Eff monad can be a bit tricky to get right if we want to avoid type annotations. Here are sometips to help you. Use context bounds and type aliasesWhen creating effects you can always \"require\" a stack containing the right effects with the `MemberIn` typeclass:``You can even use context bounds to make the declaration of `putAndTell` more concise:`` Know your `Member` typeclassesThere are 3 different ways to declare that an effect is part of an effect stack with 3 typeclasses: Typeclass             | Alias    | Meaning                                            | When to use it -----------           | -----    | --------------------                               | -------------------------------- `MemberIn[M, R]`      | `M |= R` | \"`M` is part of `R`\"                               | to create `M` effects in `R` `MemberInOut[M, R]`   | `M /= R` | \"`M` is part of `R` and can be extracted from it\"  | to intercept the effect `M` (see `Interpreter.scala`) and transform it while staying in the same stack. For example to `handleError` for an Error effect `Member[M, R]`        | `M <= R` | \"`M` is part of `R`, can be extracted from it, and the resulting stack is `m.Out`\" | to interpret the effect in terms of special values or other effects and remove the effect from the stack \"Packing\" member instancesSome function signatures can be repetitive when they always require the same list of effects:scaladef foo1[R :_foo :_bar :_baz](i: Int): Eff[R, Int]def foo2[R :_foo :_bar :_baz](i: Int): Eff[R, Int]def foo3[R :_foo :_bar :_baz](i: Int): Eff[R, Int]It is possible to \"pack\" them with the following `_effects` type definition:``The implicit definition `extractMember` in the `Members` object will take care of \"unpacking\" the member instances where required.Note that this implicit must *not* be in scope when calling the methods requiring the \"packed\" implicits otherwise it willtrigger a divergent implicit search.", "tags":"", "loc":"org.atnos.site.MemberImplicits.html"},
{"title":"Applicative", "text":" Concurrent evaluationThe default interpretation of `Eff` values is \"monadic\" meaning that effectful values are being evaluated in order. This  becomes clear when traversing a list of values with the `FutureEffect`:> List(1000, 500, 50)`We can however run all those computations concurrently using the applicative execution for `Eff`:> List(1000, 500, 50)`This uses now `traverseA` (instead of `traverse`) to do an applicative traversal and execute futures concurrently andthe fastest actions finish first.", "tags":"", "loc":"org.atnos.site.ApplicativeEvaluation.html"},
{"title":"Cookbook", "text":"A collection of examples of how to solve particular problems with Eff Partial InterpretationIt's common to want to use different effects in different parts of a program. Some effects, like error handling orlogging, may extend through the whole of our program. However we may want to include additional effects,like state, within one part.The example below shows how we can do this - the `incrementNTimes` methods uses an additional `State` effect for its implementation (necessary to call `incrementCounter`) - the additional `State` effect is added to `R` with the `prepend` method: `Fx.prepend[StateInt, R]` - `runState` is called within `incrementNTimes` to finally interpret that effect> Right((6,List(counter == 4, counter == 5, counter == 6)))`", "tags":"", "loc":"org.atnos.site.Cookbook.html"},
{"title":"Community resources", "text":"A collection of resources related to Eff. Blog posts- [A Journey into Extensible Effects in Scala](https://rea.tech/a-journey-into-extensible-effects-in-scala/) Tutorials & Examples- [Getting work done with Effectful Functional Programming](https://github.com/benhutchison/GettingWorkDoneWithExtensibleEffects)", "tags":"", "loc":"org.atnos.site.CommunityResources.html"},
{"title":"eff", "text":"Extensible effects are an alternative to monad transformers for computing with effects in a functional way.This library is based on the \"free-er\" monad and an \"open union\" of effects described byOleg Kiselyov in [Freer monads, more extensible effects](https://okmij.org/ftp/Haskell/extensible/more.pdf).You can learn more in the following sections, it is recommended to read them in order if you are new to `eff`: 1.  1.  1. : `Reader`, `Writer`, `Eval`, `State`,... 1.  1.  1.  1.  1.  1.  1.  Contributing`eff` is a [Typelevel](https://typelevel.org) project. This means we embrace pure, typeful, functional programming,and provide a safe and friendly environment for teaching, learning, and contributing as described in the [Scala Code of Conduct](https://www.scala-lang.org/conduct/).Feel free to open an issue if you notice a bug, have an idea for a feature, or have a question about the code. Pull requests are also gladly accepted.", "tags":"", "loc":"index.html"}]};
     