<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Out of the box</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-1"></div>

<div class="col-md-1"></div>




<div class="col-md-10 col-sm-9 col-xs-9">
<h1>Out of the box</h1>
<div id="tipue_search_content"></div>

<p>This library comes with the following effects:</p>
<table style="width:76%;">
<colgroup>
<col width="13%" />
<col width="62%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code class="prettyprint">EvalEffect</code></td>
<td align="left">an effect for delayed computations</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">OptionEffect</code></td>
<td align="left">an effect for optional computations, stopping when there’s no available value</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">EitherEffect</code></td>
<td align="left">an effect for computations with failures, stopping when there is a failure</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">ValidateEffect</code></td>
<td align="left">an effect for computations with failures, allowing to continue computations and to collect failures</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">ErrorEffect</code></td>
<td align="left">a mix of Eval and Either, catching exceptions and returning them as failures</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">ReaderEffect</code></td>
<td align="left">an effect for depending on a configuration or an environment</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">WriterEffect</code></td>
<td align="left">an effect to log messages</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">StateEffect</code></td>
<td align="left">an effect to pass state around</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">ListEffect</code></td>
<td align="left">an effect for computations returning several values</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">ChooseEffect</code></td>
<td align="left">an effect for modeling non-determinism</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">MemoEffect</code></td>
<td align="left">an effect for memoizing values</td>
</tr>
<tr class="even">
<td align="left"><code class="prettyprint">AsyncEffect</code></td>
<td align="left">an effect for asynchronous computations</td>
</tr>
<tr class="odd">
<td align="left"><code class="prettyprint">SafeEffect</code></td>
<td align="left">an effect for guaranteeing resource safety</td>
</tr>
</tbody>
</table>
<p><small>(from <code class="prettyprint">org.atnos.eff._</code>)</small></p>
<p>Each object provides methods to create effects and to interpret them.</p>
<h3 id="eval">Eval</h3>
<p>This effect is a very simple one. It allows the delayed execution of computations and it can serve as some sort of overall <code class="prettyprint">IO</code> effect.</p>
<p>Two methods are available to execute this effect:</p>
<ul>
<li><p><code class="prettyprint">runEval: Eff[U, A]</code> to just execute the computations</p></li>
<li><p><code class="prettyprint">attemptEval: Eff[U, Throwable \/ A]</code> to execute the computations but also catch any <code class="prettyprint">Throwable</code> that would be thrown</p></li>
</ul>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

delay(1 + 1).runEval.run</code></pre>
<p><code class="prettyprint">&gt; 2</code></p>
<h3 id="option">Option</h3>
<p>Adding an <code class="prettyprint">Option</code> effect in your stack allows to stop computations when necessary. If you create a value with <code class="prettyprint">some(a)</code> this value will be used downstream but if you use <code class="prettyprint">none</code> all computations will stop:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

/**
 * Stack declaration
 */
type S = Fx.fx1[Option]

// compute with this stack
val map: Map[String, Int] =
  Map(&quot;key1&quot; -&gt; 10, &quot;key2&quot; -&gt; 20)

// get 2 keys from the map and add the corresponding values
def addKeys(key1: String, key2: String): Eff[S, Int] = for {
  a &lt;- fromOption(map.get(key1))
  b &lt;- fromOption(map.get(key2))
} yield a + b

(addKeys(&quot;key1&quot;, &quot;key2&quot;).runOption.run, addKeys(&quot;key1&quot;, &quot;missing&quot;).runOption.run)</code></pre>
<p><code class="prettyprint">&gt; (Some(30),None)</code></p>
<h3 id="either">Either</h3>
<p>The <code class="prettyprint">Either</code> effect is similar to the <code class="prettyprint">Option</code> effect but adds the possibility to specify why a computation stopped:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

/**
 * Stack declaration
 */
type S = Fx.fx1[String Either ?]

// compute with this stack
val map: Map[String, Int] =
  Map(&quot;key1&quot; -&gt; 10, &quot;key2&quot; -&gt; 20)

// get 2 keys from the map and add the corresponding values
def addKeys(key1: String, key2: String): Eff[S, Int] = for {
  a &lt;- optionEither(map.get(key1), s&quot;&#39;$key1&#39; not found&quot;)
  b &lt;- optionEither(map.get(key2), s&quot;&#39;$key2&#39; not found&quot;)
} yield a + b

(addKeys(&quot;key1&quot;, &quot;key2&quot;).runEither.run, addKeys(&quot;key1&quot;, &quot;missing&quot;).runEither.run)</code></pre>
<p><code class="prettyprint">&gt; (Right(30),Left('missing' not found))</code></p>
<p><em>Note</em>: the <code class="prettyprint">?</code> syntax comes from the <a href="https://github.com/non/kind-projector">kind-projector</a> project and allows us to avoid type lambdas.</p>
<p>A <code class="prettyprint">catchLeft</code> method can also be used to intercept an error and possibly recover from it:</p>
<pre><code class="prettyprint">case class TooBig(value: Int)
type E = Fx.fx1[TooBig Either ?]

val i = 7

val value: Eff[E, Int] =
  if (i &gt; 5) left[E, TooBig, Int](TooBig(i))
  else       right[E, TooBig, Int](i)

val action: Eff[E, Int] = catchLeft[E, TooBig, Int](value) { case TooBig(k) =&gt;
  if (k &lt; 10) right[E, TooBig, Int](k)
  else        left[E, TooBig, Int](TooBig(k))
}

action.runEither.run ==== Right(7)</code></pre>
<p><em>Note</em>: the type annotations on <code class="prettyprint">left</code> and <code class="prettyprint">right</code> can be avoided by adding an implicit declaration in scope. You can learn more about this in the <link class="ok"><a href="org.atnos.site.MemberImplicits.html" tooltip="" class="ok">Implicits</a></link> section.</p>
<h3 id="validate">Validate</h3>
<p>The <code class="prettyprint">Validate</code> effect is similar to the <code class="prettyprint">Either</code> effect but let you accumulate failures:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

/**
 * Stack declaration
 */
type S = Fx.fx1[Validate[String, ?]]

def checkPositiveInt(i: Int): Eff[S, Unit] =
  validateCheck(i &gt;= 0, s&quot;$i is not positive&quot;)

def checkPositiveInts(a: Int, b: Int, c: Int): Eff[S, (Int, Int, Int)] = for {
  _ &lt;- checkPositiveInt(a)
  _ &lt;- checkPositiveInt(b)
  _ &lt;- checkPositiveInt(c)
} yield (a, b, c)

checkPositiveInts(1, -3, -2).runNel.run</code></pre>
<p><code class="prettyprint">&gt; Left(NonEmptyList(-3 is not positive, -2 is not positive))</code></p>
<h3 id="error">Error</h3>
<p>The <code class="prettyprint">Error</code> effect is both an <code class="prettyprint">Eval</code> effect and a <code class="prettyprint">Either</code> one with <code class="prettyprint">Throwable Either F</code> on the “left” side. The idea is to represent computations which can fail, either with an exception or a failure. You can:</p>
<ul>
<li><p>create delayed computations with <code class="prettyprint">ok</code></p></li>
<li><p>fail with <code class="prettyprint">fail(f: F)</code> where <code class="prettyprint">F</code> is the failure type</p></li>
<li><p>throw an exception with <code class="prettyprint">exception</code></p></li>
</ul>
<p>Other useful combinators are available:</p>
<ul>
<li><p><code class="prettyprint">andFinally(last)</code> registers an action to be executed even in case of an exception or a failure</p></li>
<li><p><code class="prettyprint">orElse</code> runs an action and then run another one if the first is not successful</p></li>
<li><p><code class="prettyprint">whenFailed</code> does the same thing than <code class="prettyprint">orElse</code> but uses the error for <code class="prettyprint">action1</code> to decide which action to run next</p></li>
</ul>
<p>When you run an <code class="prettyprint">Error</code> effect you get back an <code class="prettyprint">Error Either A</code> where <code class="prettyprint">Error</code> is a type alias for <code class="prettyprint">Throwable Either Failure</code>.</p>
<p>The <code class="prettyprint">Error</code> object implements this effect with <code class="prettyprint">String</code> as the <code class="prettyprint">Failure</code> type but you are encouraged to create our own failure datatype and extend the <code class="prettyprint">Error[MyFailureDatatype]</code> trait.</p>
<h3 id="reader">Reader</h3>
<p>The <code class="prettyprint">Reader</code> effect is used to request values from an “environment”. The main method is <code class="prettyprint">ask</code> to get the current environment (or “configuration” if you prefer to see it that way) and you can run an effect stack containing a <code class="prettyprint">Reader</code> effect by providing a value for the environment with the <code class="prettyprint">runReader</code> method.</p>
<p>You can also inject a “local” reader into a “bigger” one:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._
import cats.data._

case class Conf(host: String, port: Int)

type R1[A] = Reader[Int, A]
type R2[A] = Reader[Conf, A]

type S = Fx.fx2[R1, R2]

def getPort[R](implicit r: Reader[Int, ?] |= R): Eff[R, String] = for {
  p1 &lt;- ask[R, Int]
} yield &quot;the port is &quot; + p1

getPort[S].localReader((_: Conf).port).runReader(Conf(&quot;prod&quot;, 80)).run</code></pre>
<p><code class="prettyprint">&gt; the port is 80</code></p>
<h3 id="writer">Writer</h3>
<p>The <code class="prettyprint">Writer</code> effect is classically used to log values alongside computations. However it generally suffers from the following drawbacks:</p>
<ul>
<li><p>values have to be accumulated in some sort of <code class="prettyprint">Monoid</code></p></li>
<li><p>it can not really be used to log values to a file because all the values are being kept in memory until the computation ends</p></li>
</ul>
<p>The <code class="prettyprint">Writer</code> effect has none of these issues. When you want to log a value you simply <code class="prettyprint">tell</code> it and when you run the effect you can select exactly the strategy you want:</p>
<ul>
<li><p><code class="prettyprint">runWriter</code> simply accumulates the values in a <code class="prettyprint">List</code> which is ok if you don’t have too many of them</p></li>
<li><p><code class="prettyprint">runWriterFold</code> uses a <code class="prettyprint">Fold</code> to act on each value, keeping some internal state between each invocation</p></li>
</ul>
<p>You can then define your own custom <code class="prettyprint">Fold</code> to log the values to a file:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._
import java.io.PrintWriter

type S = Fx.fx1[Writer[String, ?]]

val action: Eff[S, Int] = for {
 a &lt;- pure[S, Int](1)
 _ &lt;- tell(&quot;first value &quot;+a)
 b &lt;- pure[S, Int](2)
 _ &lt;- tell(&quot;second value &quot;+b)

} yield a + b

// define a fold to output values
def fileFold(path: String) = new LeftFold[String, Unit] {
  type S = PrintWriter
  val init: S = new PrintWriter(path)

  def fold(a: String, s: S): S =
    { s.println(a); s }

  def finalize(s: S): Unit =
    s.close
}

action.runWriterFold(fileFold(&quot;target/log&quot;)).run
io.Source.fromFile(&quot;target/log&quot;).getLines.toList</code></pre>
<p><code class="prettyprint">&gt; List(first value 1, second value 2)</code></p>
<h3 id="state">State</h3>
<p>A <code class="prettyprint">State</code> effect can be seen as the combination of both a <code class="prettyprint">Reader</code> and a <code class="prettyprint">Writer</code> with these operations:</p>
<ul>
<li><p><code class="prettyprint">get</code> get the current state</p></li>
<li><p><code class="prettyprint">put</code> set a new state</p></li>
</ul>
<p>Let’s see an example showing that we can also use tags to track different states at the same time:</p>
<pre><code class="prettyprint">import cats.data._
import org.atnos.eff._, all._, syntax.all._

type S1[A] = State[Int, A]
type S2[A] = State[String, A]

type S = Fx.fx2[S1, S2]

val swapVariables: Eff[S, String] = for {
  v1 &lt;- get[S, Int]
  v2 &lt;- get[S, String]
  _  &lt;- put[S, Int](v2.size)
  _  &lt;- put[S, String](v1.toString)
  w1 &lt;- get[S, Int]
  w2 &lt;- get[S, String]
} yield &quot;initial: &quot;+(v1, v2).toString+&quot;, final: &quot;+(w1, w2).toString

swapVariables.evalState(10).evalState(&quot;hello&quot;).run</code></pre>
<p><code class="prettyprint">&gt; initial: (10,hello), final: (5,10)</code></p>
<p>In the example above we have used an <code class="prettyprint">eval</code> method to get the <code class="prettyprint">A</code> in <code class="prettyprint">Eff[R, A]</code> but it is also possible to get both the value and the state with <code class="prettyprint">run</code> or only the state with <code class="prettyprint">exec</code>.</p>
<p>Instead of tagging state effects it is also possible to transform a State effect acting on a “small” state into a State effect acting on a “bigger” state:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

type Count[A] = State[Int, A]
type Sum[A]   = State[Int, A]
type Mean[A]  = State[(Int, Int), A]

type S1 = Fx.fx1[Count]
type S2 = Fx.fx1[Sum]
type S  = Fx.fx1[Mean]

def count(list: List[Int]): Eff[S1, String] = for {
  _ &lt;- put(list.size)
} yield s&quot;there are ${list.size} values&quot;

def sum(list: List[Int]): Eff[S2, String] = {
  val s = if (list.isEmpty) 0 else list.sum
  for {
    _ &lt;- put(s)
  } yield s&quot;the sum is $s&quot;
}

def mean(list: List[Int]): Eff[S, String] = for {
  m1 &lt;- count(list).lensState((_:(Int, Int))._1, (s: (Int,Int), i: Int) =&gt; (i, s._2))
  m2 &lt;- sum(list).lensState((_:(Int, Int))._2, (s: (Int, Int), i: Int) =&gt; (s._1, i))
} yield m1+&quot;\n&quot;+m2

mean(List(1, 2, 3)).runState((0, 0)).run</code></pre>
<pre><code class="prettyprint">&gt; (there are 3 values
the sum is 6,(3,6))</code></pre>
<h3 id="list">List</h3>
<p>The <code class="prettyprint">List</code> effect is used for computations which may return several values. A simple example using this effect would be:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

type S = Fx.fx1[List]

// create all the possible pairs for a given list
// where the sum is greater than a value
def pairsBiggerThan[R :_list](list: List[Int], n: Int): Eff[R, (Int, Int)] = for {
  a &lt;- values(list:_*)
  b &lt;- values(list:_*)
  found &lt;- if (a + b &gt; n) singleton((a, b))
           else           empty
} yield found

pairsBiggerThan[S](List(1, 2, 3, 4), 5).runList.run</code></pre>
<p><code class="prettyprint">&gt; List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))</code></p>
<h3 id="choose">Choose</h3>
<p>The <code class="prettyprint">Choose</code> effect is used for non-deterministic computations. With the <code class="prettyprint">Choose</code> effect you can model computations which either:</p>
<ul>
<li>return no result at all</li>
<li>choose between 2 different computations</li>
</ul>
<p><code class="prettyprint">Choose</code> is actually a generalization of <code class="prettyprint">List</code> where instead of “exploring” all the branches we might “cut” some of them. That behaviour is controlled by the <code class="prettyprint">Alternative[F]</code> instance you use when running <code class="prettyprint">Choose</code>.</p>
<p>For example if we take <code class="prettyprint">List</code> to run a similar example as before, we get the list of all the accepted pairs:</p>
<pre><code class="prettyprint">import org.atnos.eff._, all._, syntax.all._

type S = Fx.fx1[Choose]

// create all the possible pairs for a given list
// where the sum is greater than a value
def pairsBiggerThan[R :_choose](list: List[Int], n: Int): Eff[R, (Int, Int)] = for {
  a &lt;- chooseFrom(list)
  b &lt;- chooseFrom(list)
  found &lt;- if (a + b &gt; n) EffMonad[R].pure((a, b))
           else           zero
} yield found

import cats.instances.list._

pairsBiggerThan[S](List(1, 2, 3, 4), 5).runChoose.run</code></pre>
<p><code class="prettyprint">&gt; List((2,4), (3,3), (3,4), (4,2), (4,3), (4,4))</code></p>
<h3 id="memo">Memo</h3>
<p>The Memo effect allows the caching of expensive computations. Computations are “stored” with a given key, so that the next computation with the same key will return the previously computed value. When interpreting those computations a <code class="prettyprint">Cache</code> must be provided:</p>
<pre><code class="prettyprint">import cats.Eval
import cats.implicits._
import org.atnos.eff._, memo._
import org.atnos.eff.syntax.memo._
import org.atnos.eff.syntax.eval._
import org.atnos.eff.syntax.eff._

type S = Fx.fx2[Memoized, Eval]

var i = 0

def expensive[R :_memo]: Eff[R, Int] =
  memoize(&quot;key&quot;, { i += 1; 10 * 10 })

(expensive[S] &gt;&gt; expensive[S]).runMemo(ConcurrentHashMapCache()).runEval.run === 100

&quot;there is only one invocation&quot; &lt;==&gt; (i === 1)</code></pre>
<p><code class="prettyprint">&gt; there is only one invocation &lt;=&gt; true</code></p>
<p>There are 2 cache implementations provided in this library to support the Memo effect:</p>
<ul>
<li><p><code class="prettyprint">org.atnos.eff.ConcurrentHashMapCache</code>: backed by a <code class="prettyprint">java.util.concurrent.ConcurrentHashMap</code> where the keys are hashcodes for the keys used to memoize the values. This cache is thread-safe but unbounded so use with care!</p></li>
<li><p><code class="prettyprint">org.atnos.eff.ConcurrentWeakIdentityHashMapCache</code>: backed by a <code class="prettyprint">ConcurrentWeakIdentityHashMap</code> where the keys are <code class="prettyprint">System.identityHashCode</code> for the keys used to memoize the values. This cache is thread-safe and uses weak references which can be garbage collected when necessary.</p></li>
</ul>
<p>You can also use other, and better, cache implementations like <a href="https://github.com/ben-manes/caffeine">Caffeine</a> to get more functionalities like eviction policies, maximum size and so on. You will need to implement the <code class="prettyprint">Cache</code> interface for this</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Cache {
  <span class="kw">def</span> memo[V](key: K1, value: =&gt;V): V
}</code></pre></div>
<h3 id="async">Async</h3>
<p>The Async effect is an “abstract” effect. This means that you can create asynchronous expressions using the same API and have it implemented using either <a href="http://docs.scala-lang.org/overviews/core/futures.html">Scala <code class="prettyprint">Future</code></a> or <a href="http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/">Scalaz <code class="prettyprint">Task</code></a> or <a href="https://monix.io/docs/2x/eval/task.html">Monix <code class="prettyprint">Task</code></a>.</p>
<p>For the following example we will assume an implementation using regular Scala futures. Let’s create some <code class="prettyprint">Async</code> effects:</p>
<pre><code class="prettyprint">import org.atnos.eff._
import org.atnos.eff.async._
import org.atnos.eff.syntax.all._

import scala.concurrent._, duration._
import scala.concurrent.ExecutionContext.Implicits.global

type R = Fx.fx2[Async, Option]

val action: Eff[R, Int] =
  for {
    // create a value now
    a &lt;- asyncNow[R, Int](1)

    // evaluate a value later
    b &lt;- asyncDelay[R, Int](1)

    // evaluate a value asynchronously
    c &lt;- asyncFork[R, Int](a + b)
  } yield c

</code></pre>
<p>Then we need an interpreter to interpret them as <code class="prettyprint">Futures</code>. The <code class="prettyprint">AsyncFutureInterpreter.create</code> method uses an implicit <code class="prettyprint">ExecutionContext</code> to create the interpreter. If we import the interpreter methods we can finally invoke <code class="prettyprint">runAsyncFuture</code> to get a <code class="prettyprint">Future</code> back.</p>
<pre><code class="prettyprint">
val interpreter = AsyncFutures.create
import interpreter._

Await.result(action.runOption.runAsyncFuture, 1 second)</code></pre>
<p><code class="prettyprint">&gt; Some(2)</code></p>
<p>If you prefer to use monix or scalaz you need to add a dependency on <code class="prettyprint">eff-monix</code> or <code class="prettyprint">eff-scalaz</code> and create the corresponding <code class="prettyprint">org.atnos.eff.monix.AsyncTaskInterpreter</code> or <code class="prettyprint">org.atnos.eff.addon.scalaz.concurrent.AsyncTaskInterpreter</code>:</p>
<pre><code class="prettyprint">import org.atnos.eff._

import java.util.concurrent._
import scalaz.concurrent._

implicit val es = Strategy.DefaultExecutorService
val scalazService: AsyncTaskInterpreter =
  org.atnos.eff.addon.scalaz.concurrent.AsyncTaskInterpreter.create

// the monix service doesn&#39;t require any implicit context!
val monixService: AsyncTaskInterpreter =
  org.atnos.eff.monix.addon.AsyncTaskInterpreter</code></pre>
<p>Future computations can also be memoized to avoid expensive computations to be done several times. You can either</p>
<ul>
<li>use the <code class="prettyprint">asyncMemo</code> operator with a (mutable) cache</li>
<li>use the <code class="prettyprint">asyncMemoized</code> operator with the <code class="prettyprint">Memoized</code> effect (you will need to provide the cache later)
<p/></li>
</ul>
<pre><code class="prettyprint">import cats.implicits._
import org.atnos.eff._, all._
import org.atnos.eff.syntax.all._
import scala.concurrent._, duration._
import scala.concurrent.ExecutionContext.Implicits.global

var i = 0

def expensive[R :_Async :_memo]: Eff[R, Int] =
  asyncMemoized(asyncFork[R, Int] { i += 1; 10 * 10})

val interpreter = AsyncFutures.create
import interpreter._

type S = Fx.fx2[Memoized, Async]

val future: Future[Int] =
  (expensive[S] &gt;&gt; expensive[S]).runAsyncMemo(ConcurrentHashMapCache()).runAsyncFuture

Await.result(future, 1.second)

&quot;there is only one invocation&quot; &lt;==&gt; (i === 1)</code></pre>
<p><code class="prettyprint">&gt; there is not only one invocation because false</code></p>
<h3 id="safe">Safe</h3>
<p>The Safe effect is useful to handle resources which must be closed even in the presence of exceptions. The main operations are</p>
<ul>
<li><code class="prettyprint">finally</code> to create an action which must always be executed after another one, even if the first one fails</li>
<li><code class="prettyprint">catchThrowable</code> to handle a thrown exception</li>
<li><code class="prettyprint">bracket(open)(step)(close)</code> to open a resource, use it and then close it safely. The <code class="prettyprint">close</code> part is a “finalizer” <br/></li>
</ul>
<p>Let’s see an example for the protection of a resource:</p>
<pre><code class="prettyprint">import org.atnos.eff.syntax.all._
import org.atnos.eff._, all._
import cats.Eval

// let&#39;s represent a resource which can be in use
case class Resource(values: List[Int] = (1 to 10).toList, inUse: Boolean = false) {
  def isClosed = !inUse
}

var resource = Resource()

// our stack of effects, with safe evaluation
type S = Fx.fx1[Safe]

def openResource: Eff[S, Resource] =
  protect { resource = resource.copy(inUse = true); resource }

def closeResource(r: Resource): Eff[S, Unit] =
  protect(resource = r.copy(inUse = false))

def useResource(ok: Boolean) = (r: Resource) =&gt;
  protect[S, Int](if (ok) r.values.sum else throw new Exception(&quot;boo&quot;))

// this program uses the resource safely even if there is an exception
def program(ok: Boolean): (Throwable Either Int, List[Throwable]) =
  bracket(openResource)(useResource(ok))(closeResource).
    runSafe.run</code></pre>
<pre><code class="prettyprint">&gt; Results
Without exception: Right(55), finalizers exceptions: no exceptions, resource is closed: true
With exception   : Left(boo), finalizers exceptions: no exceptions, resource is closed: true</code></pre>
<p>As you can see in the signature of <code class="prettyprint">program</code> the return value of <code class="prettyprint">runSafe</code> is <code class="prettyprint">(Throwable Either A, List[Throwable])</code>. The first part is the result of your program, which may end with an exception, and the second part is the list of possible exceptions thrown by the finalizers which can themselves fail.</p>
<p>A simpler version of <code class="prettyprint">bracket</code> is <code class="prettyprint">finally</code>.</p>
<p>This example show how to use <code class="prettyprint">finally</code> but also what happens if a finalizer fails:</p>
<pre><code class="prettyprint">import org.atnos.eff.syntax.all._
import org.atnos.eff._, all._

// our stack of effects, with safe evaluation
type S = Fx.fx1[Safe]

var sumDone: Boolean = false

def setDone(ok: Boolean): Eff[S, Unit] =
  protect[S, Unit](if (ok) sumDone = true else throw new Exception(&quot;failed!!&quot;))

// this program tries to set sumDone to true when the computation is done
def program(ok: Boolean, finalizeOk: Boolean): (Throwable Either Int, List[Throwable]) =
  (protect[S, Int](if (ok) (1 to 10).sum else throw new Exception(&quot;boo&quot;)) `finally` setDone(finalizeOk)).
    runSafe.run
</code></pre>
<pre><code class="prettyprint">&gt; Results
Computation ok, finalizer ok: Right(55), finalizers exceptions: no exceptions
Computation ok, finalizer ko: Right(55), finalizers exceptions: List(failed!!)
Computation ko, finalizer ok: Left(boo), finalizers exceptions: no exceptions
Computation ko, finalizer ko: Left(boo), finalizers exceptions: List(failed!!)</code></pre>
<p>Finally (no pun intended!) note that you can use <code class="prettyprint">execSafe</code> if you are not interested in the result of the finalizers.</p>
<p><br/></p>
<h2 id="whats-next">What’s next?</h2>
<p>Now you can learn how to <link class="ok"><a href="org.atnos.site.CreateEffects.html" tooltip="" class="ok">create your own effects</a></link>!</p>
</div>

</div>

</body>
</html>